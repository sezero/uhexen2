Alternative sdl audio driver (sdlaudio updates):

Copied QuakeForge bits. Sampling rates 44100 and
48000 are OK, 22050 seems good enough, but 11025
has a noticable latency.

New 2005-07-07: Allocate the buffer on the hunk
New 2006-01-12: Merged quake3 bits to cure most
		of the latency issues
New 2006-09-27: Re-diff'ed after the latest changes
New 2006-10-14: Made buffer allocation method a
		compile-time option: Either allocate
		on the hunk, or use system memory.
		System memory is default. Changed the
		samples multiplier from 10 to 8 .


diff -urNp hexen2source-1.4.1/hexen2/snd_sdl.c hexen2source-1.4.1x/hexen2/snd_sdl.c
--- hexen2source-1.4.1/hexen2/snd_sdl.c	2006-09-30 13:48:33.000000000 +0300
+++ hexen2source-1.4.1x/hexen2/snd_sdl.c	2006-10-14 19:14:46.000000000 +0300
@@ -16,20 +16,61 @@
 
 #include "sdl_inc.h"
 
+// whether to use hunk for allocating dma
+// buffer memory. either 1, or 0.
+#define USE_HUNK_ALLOC		0
+
+static int	buffersize;
+
+extern int	soundtime;
+
+// =======================================================================
+
 static void paint_audio(void *unused, Uint8 *stream, int len)
 {
+	int pos, tobufend;
+	int len1, len2;
+
 	if ( !shm )
+	{	// shouldn't happen, but just in case...
+		memset(stream, '\0', len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
+
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
+
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	// wraparound?
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
 
-	shm->buffer = stream;
-	shm->samplepos += len/(shm->samplebits/8)/2;
-	// Check for samplepos overflow?
-	S_PaintChannels (shm->samplepos);
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init(void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	if (SDL_InitSubSystem (SDL_INIT_AUDIO) < 0)
@@ -42,7 +83,14 @@ qboolean S_SDL_Init(void)
 	desired.freq = desired_speed;
 	desired.format = (desired_bits == 16) ? AUDIO_S16SYS : AUDIO_U8;
 	desired.channels = desired_channels;
-	desired.samples  = 1024; // previously 512 S.A.
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	// (*shrug*)
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -68,6 +116,8 @@ qboolean S_SDL_Init(void)
 		return 0;
 	}
 
+	SDL_LockAudio();
+
 	memset ((dma_t *) &sn, 0, sizeof(sn));
 	shm = &sn;
 
@@ -78,18 +128,41 @@ qboolean S_SDL_Init(void)
 		Con_Printf ("Warning: Rate set (%d) didn't match requested rate (%d)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples*shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 8;
+	if (tmp & (tmp - 1))
+	{	// make it a power of two.
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+#if USE_HUNK_ALLOC
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
+#else
+	shm->buffer = calloc (1, buffersize);
+	if (!shm->buffer)
+	{
+		SDL_CloseAudio();
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+		shm = NULL;
+		Con_Printf ("Failed allocating memory for SDL audio\n");
+		return 0;
+	}
+#endif
 
 	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
-	Con_Printf ("SDL audio driver: %s\n", drivername);
+	Con_Printf ("SDL audio driver: %s, buffer size: %d\n", drivername, buffersize);
 
 	return 1;
 }
@@ -104,8 +177,13 @@ void S_SDL_Shutdown(void)
 	if (shm)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
-//		SDL_PauseAudio(1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio();
 		SDL_CloseAudio();
+#if !USE_HUNK_ALLOC
+		if (shm->buffer)
+			free (shm->buffer);
+#endif
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 		shm->buffer = NULL;
 		shm = NULL;
diff -urNp hexen2source-1.4.1/hexen2/snd_sys.h hexen2source-1.4.1x/hexen2/snd_sys.h
--- hexen2source-1.4.1/hexen2/snd_sys.h	2006-09-30 02:08:06.000000000 +0300
+++ hexen2source-1.4.1x/hexen2/snd_sys.h	2006-09-30 13:50:30.000000000 +0300
@@ -70,7 +70,7 @@
 
 // this prevents running S_Update_() with the sdl sound driver
 // if the snd_sdl implementation already calls S_PaintChannels.
-#define SDLSOUND_PAINTS_CHANNELS	1
+#define SDLSOUND_PAINTS_CHANNELS	0
 
 #if defined(PLATFORM_WINDOWS)
 // for the windows crap used in snd_dma.c
diff -urNp hexen2source-1.4.1/hexenworld/Client/snd_sdl.c hexen2source-1.4.1x/hexenworld/Client/snd_sdl.c
--- hexen2source-1.4.1/hexenworld/Client/snd_sdl.c	2006-09-30 13:48:33.000000000 +0300
+++ hexen2source-1.4.1x/hexenworld/Client/snd_sdl.c	2006-10-14 19:16:40.000000000 +0300
@@ -16,20 +16,61 @@
 
 #include "sdl_inc.h"
 
+// whether to use hunk for allocating dma
+// buffer memory. either 1, or 0.
+#define USE_HUNK_ALLOC		0
+
+static int	buffersize;
+
+extern int	soundtime;
+
+// =======================================================================
+
 static void paint_audio(void *unused, Uint8 *stream, int len)
 {
+	int pos, tobufend;
+	int len1, len2;
+
 	if ( !shm )
+	{	// shouldn't happen, but just in case...
+		memset(stream, '\0', len);
 		return;
+	}
+
+	pos = (shm->samplepos * (shm->samplebits/8));
+	if (pos >= buffersize)
+		shm->samplepos = pos = 0;
+
+	tobufend = buffersize - pos;  /* bytes to buffer's end. */
+	len1 = len;
+	len2 = 0;
+
+	if (len1 > tobufend)
+	{
+		len1 = tobufend;
+		len2 = len - len1;
+	}
+
+	memcpy(stream, shm->buffer + pos, len1);
+
+	if (len2 <= 0)
+	{
+		shm->samplepos += (len1 / (shm->samplebits/8));
+	}
+	else
+	{	// wraparound?
+		memcpy(stream+len1, shm->buffer, len2);
+		shm->samplepos = (len2 / (shm->samplebits/8));
+	}
 
-	shm->buffer = stream;
-	shm->samplepos += len/(shm->samplebits/8)/2;
-	// Check for samplepos overflow?
-	S_PaintChannels (shm->samplepos);
+	if (shm->samplepos >= buffersize)
+		shm->samplepos = 0;
 }
 
 qboolean S_SDL_Init(void)
 {
 	SDL_AudioSpec desired, obtained;
+	int		tmp, val;
 	char	drivername[128];
 
 	if (SDL_InitSubSystem (SDL_INIT_AUDIO) < 0)
@@ -42,7 +83,14 @@ qboolean S_SDL_Init(void)
 	desired.freq = desired_speed;
 	desired.format = (desired_bits == 16) ? AUDIO_S16SYS : AUDIO_U8;
 	desired.channels = desired_channels;
-	desired.samples  = 1024; // previously 512 S.A.
+	if (desired.freq <= 11025)
+		desired.samples = 256;
+	else if (desired.freq <= 22050)
+		desired.samples = 512;
+	else if (desired.freq <= 44100)
+		desired.samples = 1024;
+	else
+		desired.samples = 2048;	// (*shrug*)
 	desired.callback = paint_audio;
 	desired.userdata = NULL;
 
@@ -68,6 +116,8 @@ qboolean S_SDL_Init(void)
 		return 0;
 	}
 
+	SDL_LockAudio();
+
 	memset ((dma_t *) &sn, 0, sizeof(sn));
 	shm = &sn;
 
@@ -78,18 +128,41 @@ qboolean S_SDL_Init(void)
 		Con_Printf ("Warning: Rate set (%d) didn't match requested rate (%d)!\n", obtained.freq, desired_speed);
 	shm->speed = obtained.freq;
 	shm->channels = obtained.channels;
-	shm->samples = obtained.samples*shm->channels;
+	tmp = (obtained.samples * obtained.channels) * 8;
+	if (tmp & (tmp - 1))
+	{	// make it a power of two.
+		val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+	shm->samples = tmp;
 	shm->samplepos = 0;
 	shm->submission_chunk = 1;
 
-	shm->buffer = NULL;
+	buffersize = shm->samples * (shm->samplebits / 8);
+#if USE_HUNK_ALLOC
+	shm->buffer = Hunk_AllocName(buffersize, "sdl_audio");
+#else
+	shm->buffer = calloc (1, buffersize);
+	if (!shm->buffer)
+	{
+		SDL_CloseAudio();
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+		shm = NULL;
+		Con_Printf ("Failed allocating memory for SDL audio\n");
+		return 0;
+	}
+#endif
 
 	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
 
+	SDL_UnlockAudio();
 	SDL_PauseAudio(0);
 
-	Con_Printf ("SDL audio driver: %s\n", drivername);
+	Con_Printf ("SDL audio driver: %s, buffer size: %d\n", drivername, buffersize);
 
 	return 1;
 }
@@ -104,8 +177,13 @@ void S_SDL_Shutdown(void)
 	if (shm)
 	{
 		Con_Printf ("Shutting down SDL sound\n");
-//		SDL_PauseAudio(1);
+		SDL_PauseAudio(1);
+		SDL_LockAudio();
 		SDL_CloseAudio();
+#if !USE_HUNK_ALLOC
+		if (shm->buffer)
+			free (shm->buffer);
+#endif
 		SDL_QuitSubSystem(SDL_INIT_AUDIO);
 		shm->buffer = NULL;
 		shm = NULL;
diff -urNp hexen2source-1.4.1/hexenworld/Client/snd_sys.h hexen2source-1.4.1x/hexenworld/Client/snd_sys.h
--- hexen2source-1.4.1/hexenworld/Client/snd_sys.h	2006-09-30 02:08:06.000000000 +0300
+++ hexen2source-1.4.1x/hexenworld/Client/snd_sys.h	2006-09-30 13:50:30.000000000 +0300
@@ -70,7 +70,7 @@
 
 // this prevents running S_Update_() with the sdl sound driver
 // if the snd_sdl implementation already calls S_PaintChannels.
-#define SDLSOUND_PAINTS_CHANNELS	1
+#define SDLSOUND_PAINTS_CHANNELS	0
 
 #if defined(PLATFORM_WINDOWS)
 // for the windows crap used in snd_dma.c

