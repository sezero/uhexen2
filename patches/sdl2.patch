initial SDL2 patch - based on a work by jpernst
at: https://github.com/jpernst/uhexen2-sdl2.git

things do seem to work but needs some polishing
and tidy-up before making it mainstream.

diff --git a/engine/h2shared/gl_vidsdl.c b/engine/h2shared/gl_vidsdl.c
index ae29dd0..7b35469 100644
--- a/engine/h2shared/gl_vidsdl.c
+++ b/engine/h2shared/gl_vidsdl.c
@@ -116,8 +116,13 @@ typedef struct {
 } attributes_t;
 static attributes_t	vid_attribs;
 
+#if (SDLQUAKE > 1)
+static SDL_Window	*window;
+static SDL_GLContext	glcontext;
+#else
 static const SDL_VideoInfo	*vid_info;
 static SDL_Surface	*screen;
+#endif
 static qboolean	vid_menu_fs;
 static qboolean	fs_toggle_works = true;
 
@@ -277,12 +282,20 @@ void VID_HandlePause (qboolean paused)
 
 qboolean VID_HasMouseOrInputFocus (void)
 {
+#if (SDLQUAKE > 1)
+	return (SDL_GetWindowFlags(window) & (SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_INPUT_FOCUS)) != 0;
+#else
 	return (SDL_GetAppState() & (SDL_APPMOUSEFOCUS | SDL_APPINPUTFOCUS)) != 0;
+#endif
 }
 
 qboolean VID_IsMinimized (void)
 {
+#if (SDLQUAKE > 1)
+	return !(SDL_GetWindowFlags(window) & SDL_WINDOW_SHOWN);
+#else
 	return !(SDL_GetAppState() & SDL_APPACTIVE);
+#endif
 }
 
 
@@ -307,16 +320,28 @@ static void VID_SetIcon (void)
 	if (icon == NULL)
 		return;
 
+#if SDLQUAKE == 1
 	SDL_SetColorKey(icon, SDL_SRCCOLORKEY, 0);
+#else
+	SDL_SetColorKey(icon, SDL_TRUE, 0);
+#endif
 
 	color.r = 255;
 	color.g = 255;
 	color.b = 255;
+#if SDLQUAKE == 1
 	SDL_SetColors(icon, &color, 0, 1);	/* just in case */
+#else
+	SDL_SetPaletteColors(icon->format->palette, &color, 0, 1);
+#endif
 	color.r = 192;
 	color.g = 0;
 	color.b = 0;
+#if SDLQUAKE == 1
 	SDL_SetColors(icon, &color, 1, 1);
+#else
+	SDL_SetPaletteColors(icon->format->palette, &color, 1, 1);
+#endif
 
 	ptr = (Uint8 *)icon->pixels;
 	/* one bit represents a pixel, black or white:  each
@@ -330,8 +355,13 @@ static void VID_SetIcon (void)
 		}
 	}
 
+#if SDLQUAKE == 1
 	SDL_WM_SetIcon(icon, NULL);
+#else
+	SDL_SetWindowIcon(window, icon);
+#endif
 	SDL_FreeSurface(icon);
+
 #endif /* !OSX */
 }
 
@@ -413,14 +443,14 @@ static qboolean VID_SetMode (int modenum)
 {
 	Uint32	flags;
 	int	i, is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h, scaling_factor = 100;
+#endif
 
 	in_mode_set = true;
 
-	//flags = (SDL_OPENGL|SDL_NOFRAME);
-	flags = (SDL_OPENGL);
-	if (vid_config_fscr.integer)
-		flags |= SDL_FULLSCREEN;
-
 	// setup the attributes
 	if (bpp >= 32)
 	{
@@ -453,6 +483,81 @@ static qboolean VID_SetMode (int modenum)
 
 	Con_SafePrintf ("Requested mode %d: %dx%dx%d\n", modenum, modelist[modenum].width, modelist[modenum].height, bpp);
 
+#if SDLQUAKE == 2
+	// Create the window without the fullscreen flag first so we can query its display and check the desktop resolution
+	window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI);
+
+	// Start with empty flags until we determine the fullscreen mode
+	flags = 0;
+	if (vid_config_fscr.integer)
+	{
+		flags = SDL_WINDOW_FULLSCREEN;
+
+		// Try to check the desktop resolution. If it matches the window size, use a borderless window
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			int drawable_w, drawable_h;
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			SDL_GL_GetDrawableSize(window, &drawable_w, &drawable_h);
+
+			scaling_factor = (100 * drawable_w) / screen_w;
+
+			if (scaling_factor != 100)
+				Con_Printf ("High DPI scaling in effect! (%d%%)\n", scaling_factor);
+
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+
+	if (!window)
+	{
+		if (!multisample)
+			Sys_Error ("Couldn't set video mode: %s", SDL_GetError());
+		else
+		{
+			Con_SafePrintf ("multisample window failed\n");
+			multisample = 0;
+			SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
+			SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, multisample);
+			// Add OpenGL flag back in
+			flags |= SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI;
+			window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, flags);
+			if (!window)
+				Sys_Error ("Couldn't set video mode: %s", SDL_GetError());
+		}
+	} else
+		// Now that we have the fullscreen flags, set them
+		SDL_SetWindowFullscreen(window, flags);
+
+	// Modify mode with real width and height
+	modelist[modenum].width = modelist[modenum].width * scaling_factor / 100;
+	modelist[modenum].height = modelist[modenum].height * scaling_factor / 100;
+
+	glcontext = SDL_GL_CreateContext(window);
+	if (!glcontext)
+	{
+		SDL_DestroyWindow(window);
+		window = NULL;
+		Sys_Error ("Couldn't create gl context: %s", SDL_GetError());
+	}
+
+	VID_SetIcon();
+	SDL_SetWindowTitle(window, WM_TITLEBAR_TEXT);
+
+	is_fullscreen = (SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP)) ? 1 : 0;
+#else
+	//flags = (SDL_OPENGL|SDL_NOFRAME);
+	flags = (SDL_OPENGL);
+	if (vid_config_fscr.integer)
+		flags |= SDL_FULLSCREEN;
+
 	VID_SetIcon();
 
 	screen = SDL_SetVideoMode (modelist[modenum].width, modelist[modenum].height, bpp, flags);
@@ -474,9 +579,13 @@ static qboolean VID_SetMode (int modenum)
 		}
 	}
 
+	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+
+	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
+#endif
+
 	// set vid_modenum properly and adjust other vars
 	vid_modenum = modenum;
-	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
 	modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 	Cvar_SetValueQuick (&vid_config_glx, modelist[vid_modenum].width);
 	Cvar_SetValueQuick (&vid_config_gly, modelist[vid_modenum].height);
@@ -496,8 +605,6 @@ static qboolean VID_SetMode (int modenum)
 	}
 	Cvar_SetValueQuick (&vid_config_fsaa, multisample);
 
-	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
-
 	IN_HideMouse ();
 
 	in_mode_set = false;
@@ -670,6 +777,7 @@ static void VID_InitGamma (void)
 		fx_gamma = VID_Check3dfxGamma();
 	if (!fx_gamma)
 	{
+#if SDLQUAKE < 2
 #if USE_GAMMA_RAMPS
 		gammaworks	= (SDL_GetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]) == 0);
 		if (gammaworks)
@@ -677,6 +785,7 @@ static void VID_InitGamma (void)
 #else
 		gammaworks	= (SDL_SetGamma(1, 1, 1) == 0);
 #endif
+#endif
 	}
 
 	if (!gammaworks && !fx_gamma)
@@ -691,11 +800,13 @@ static void VID_ShutdownGamma (void)
 /*	if (fx_gamma) do3dfxGammaCtrl(1);*/
 #endif
 	Shutdown_3dfxGamma();
+#if SDLQUAKE < 2
 #if USE_GAMMA_RAMPS	/* restore hw-gamma */
 	if (gammaworks) SDL_SetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]);
 #else
 	if (gammaworks) SDL_SetGamma (1,1,1);
 #endif
+#endif
 }
 
 static void VID_SetGamma (void)
@@ -709,11 +820,13 @@ static void VID_SetGamma (void)
 #else
 	if (fx_gamma) do3dfxGammaCtrl(value);
 #endif
+#if SDLQUAKE < 2
 #if USE_GAMMA_RAMPS
 	if (gammaworks) SDL_SetGammaRamp(ramps[0], ramps[1], ramps[2]);
 #else
 	if (gammaworks) SDL_SetGamma(value,value,value);
 #endif
+#endif
 }
 
 void VID_ShiftPalette (const unsigned char *palette)
@@ -1040,7 +1153,12 @@ void GL_BeginRendering (int *x, int *y, int *width, int *height)
 void GL_EndRendering (void)
 {
 	if (!scr_skipupdate)
+#if SDLQUAKE == 2
+		SDL_GL_SwapWindow(window);
+#else
 		SDL_GL_SwapBuffers();
+#endif
+
 
 // handle the mouse state when windowed if that's changed
 	if (_enable_mouse.integer != enable_mouse /*&& modestate == MS_WINDOWED*/)
@@ -1254,8 +1372,13 @@ static void VID_ChangeVideoMode (int newmode)
 {
 	int	temp;
 
+#if SDLQUAKE < 2
 	if (!screen)
 		return;
+#else
+	if (!window)
+		return;
+#endif
 
 	temp = scr_disabled_for_loading;
 	scr_disabled_for_loading = true;
@@ -1281,7 +1404,12 @@ static void VID_ChangeVideoMode (int newmode)
 	IN_ShowMouse ();
 
 	// Kill device and rendering contexts
+#if SDLQUAKE == 2
+	SDL_GL_DeleteContext(glcontext);
+	SDL_DestroyWindow(window);
+#else
 	SDL_FreeSurface(screen);
+#endif
 	SDL_QuitSubSystem(SDL_INIT_VIDEO);	// also unloads the opengl driver
 
 	// re-init sdl_video, set the mode and re-init opengl
@@ -1293,7 +1421,9 @@ static void VID_ChangeVideoMode (int newmode)
 #endif
 	VID_SetMode (newmode);
 	// re-get the video info since we re-inited sdl_video
+#if SDLQUAKE < 2
 	vid_info = SDL_GetVideoInfo();
+#endif
 
 	// Reload graphics wad file (Draw_PicFromWad writes glpic_t data (sizes,
 	// texnums) right on top of the original pic data, so the pic data will
@@ -1364,10 +1494,68 @@ static int sort_modes (const void *arg1, const void *arg2)
 	return a1->width - a2->width;
 }
 
-static void VID_PrepareModes (SDL_Rect **sdl_modes)
+static void VID_PrepareModes (void)
 {
 	int	i, j;
 	qboolean	not_multiple;
+	SDL_Rect	**sdl_modes;
+#if SDLQUAKE == 2
+	int k;
+	SDL_DisplayMode	mode;
+	SDL_Rect	mode_rects[MAX_MODE_LIST];
+	SDL_Rect	*ptr_array[MAX_MODE_LIST + 1];
+#endif
+
+#if SDLQUAKE == 2
+	// SDL2 does not have a function to get the full modelist, so we must build it manually.
+
+	num_fmodes = 0;
+
+	// Fill the list with all modes supported by the first display.
+	for (i = 0; i < SDL_GetNumDisplayModes(0) && i < MAX_MODE_LIST; i++)
+	{
+		SDL_GetDisplayMode(0, i, &mode);
+		mode_rects[num_fmodes].x = 0;
+		mode_rects[num_fmodes].y = 0;
+		mode_rects[num_fmodes].w = mode.w;
+		mode_rects[num_fmodes].h = mode.h;
+		num_fmodes++;
+	}
+
+	// Check the other displays and add any modes that aren't already in the list
+	for (i = 1; i < SDL_GetNumVideoDisplays(); i++)
+		for (j = 0; j < SDL_GetNumDisplayModes(i) && num_fmodes < MAX_MODE_LIST; j++)
+		{
+			SDL_GetDisplayMode(i, j, &mode);
+			mode_rects[num_fmodes].x = 0;
+			mode_rects[num_fmodes].y = 0;
+			mode_rects[num_fmodes].w = mode.w;
+			mode_rects[num_fmodes].h = mode.h;
+			num_fmodes++;
+
+			for (k = 0; k < num_fmodes; k++)
+			{
+				if (mode.w == mode_rects[k].w && mode.h == mode_rects[k].h)
+				{
+					num_fmodes--;
+					break;
+				}
+			}
+		}
+
+	if (num_fmodes > 0)
+	{
+		for (i = 0; i < num_fmodes; i++)
+			ptr_array[i] = &mode_rects[i];
+		ptr_array[num_fmodes] = NULL;
+		sdl_modes = ptr_array;
+	}
+	else
+		sdl_modes = NULL;
+#else
+	// retrieve the list of fullscreen modes
+	sdl_modes = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	num_fmodes = 0;
 	num_wmodes = 0;
@@ -1553,9 +1741,10 @@ void	VID_Init (const unsigned char *palette)
 	static char fxmesa_env_multitex[32] = "FX_DONT_FAKE_MULTITEX=1";
 	static char fxglide_env_nosplash[32] = "FX_GLIDE_NO_SPLASH=1";
 #endif
-	int	i, temp, width, height;
-	SDL_Rect	**enumlist;
+#if SDLQUAKE < 2
 	const SDL_version	*sdl_version;
+#endif
+	int	i, temp, width, height;
 	const char	*read_vars[] = {
 				"vid_config_fscr",
 				"vid_config_gl8bit",
@@ -1591,9 +1780,13 @@ void	VID_Init (const unsigned char *palette)
 	vid.numpages = 2;
 
 	// see if the SDL version we linked to is multisampling-capable
+#if SDLQUAKE == 2
+	sdl_has_multisample = true;
+#else
 	sdl_version = SDL_Linked_Version();
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) >= SDL_VER_WITH_MULTISAMPLING)
 		sdl_has_multisample = true;
+#endif
 
 #ifndef __MORPHOS__
 	// enable vsync for nvidia geforce or newer - S.A
@@ -1636,10 +1829,9 @@ void	VID_Init (const unsigned char *palette)
 
 	// this will contain the "best bpp" for the current display
 	// make sure to re-retrieve it if you ever re-init sdl_video
+#if SDLQUAKE < 2
 	vid_info = SDL_GetVideoInfo();
-
-	// retrieve the list of fullscreen modes
-	enumlist = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	i = COM_CheckParm("-bpp");
 	if (i && i < com_argc-1)
@@ -1648,7 +1840,7 @@ void	VID_Init (const unsigned char *palette)
 	}
 
 	// prepare the modelists, find the actual modenum for vid_default
-	VID_PrepareModes(enumlist);
+	VID_PrepareModes();
 
 	// set vid_mode to our safe default first
 	Cvar_SetValueQuick (&vid_mode, vid_default);
@@ -1784,6 +1976,14 @@ void	VID_Init (const unsigned char *palette)
 void	VID_Shutdown (void)
 {
 	VID_ShutdownGamma();
+
+#if SDLQUAKE == 2
+	if (glcontext)
+		SDL_GL_DeleteContext(glcontext);
+	if (window)
+		SDL_DestroyWindow(window);
+#endif
+
 	SDL_QuitSubSystem(SDL_INIT_VIDEO);
 }
 
@@ -1799,21 +1999,63 @@ extern qboolean menu_disabled_mouse;
 void VID_ToggleFullscreen (void)
 {
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int fullscreen_flag;
+#endif
 
 	if (!fs_toggle_works)
 		return;
 	if (!num_fmodes)
 		return;
+#if SDLQUAKE == 2
+	if (!window)
+#else
 	if (!screen)
+#endif
 		return;
 
 	S_ClearBuffer ();
 
+#if SDLQUAKE == 2
+	is_fullscreen = SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// If we're switching to fullscreen, check to see if our window has the same size as the desktop.
+	// If it does, use a borderless window instead of "real" fullscreen for better wm integration.
+	if (!is_fullscreen)
+	{
+		fullscreen_flag = SDL_WINDOW_FULLSCREEN;
+
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				fullscreen_flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+	else
+		fullscreen_flag = 0;
+
+	if (SDL_SetWindowFullscreen(window, fullscreen_flag) == 0)
+#else
 	// This doesn't seem to cause any trouble even
 	// with is_3dfx == true and FX_GLX_MESA == f
 	if (SDL_WM_ToggleFullScreen(screen) == 1)
+#endif
 	{
+#if SDLQUAKE == 2
+		is_fullscreen = !is_fullscreen;
+#else
 		is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+#endif
 		Cvar_SetValueQuick(&vid_config_fscr, is_fullscreen);
 		modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 		if (is_fullscreen)
@@ -1837,7 +2079,11 @@ void VID_ToggleFullscreen (void)
 	else
 	{
 		fs_toggle_works = false;
+#if SDLQUAKE == 2
+		Con_Printf ("SDL_SetWindowFulscreen failed\n");
+#else
 		Con_Printf ("SDL_WM_ToggleFullScreen failed\n");
+#endif
 	}
 }
 
diff --git a/engine/h2shared/in_sdl.c b/engine/h2shared/in_sdl.c
index f1b3c62..ce81489 100644
--- a/engine/h2shared/in_sdl.c
+++ b/engine/h2shared/in_sdl.c
@@ -44,8 +44,10 @@ static int buttonremap[] =
 	K_MOUSE1,
 	K_MOUSE3,	/* right button		*/
 	K_MOUSE2,	/* middle button	*/
+#if SDLQUAKE == 1
 	K_MWHEELUP,
 	K_MWHEELDOWN,
+#endif
 	K_MOUSE4,
 	K_MOUSE5
 };
@@ -190,7 +192,11 @@ void IN_ActivateMouse (void)
 		{
 			mouseactivatetoggle = true;
 			mouseactive = true;
+#if SDLQUAKE == 2
+			SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 			SDL_WM_GrabInput (SDL_GRAB_ON);
+#endif
 		}
 	    }
 	}
@@ -215,7 +221,11 @@ void IN_DeactivateMouse (void)
 	    if (mouseactivatetoggle) {
 		mouseactivatetoggle = false;
 		mouseactive = false;
+#if SDLQUAKE == 2
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput (SDL_GRAB_OFF);
+#endif
 	    }
 	}
 
@@ -232,7 +242,11 @@ static void IN_StartupMouse (void)
 /*	IN_HideMouse ();*/
 	if (safemode || COM_CheckParm ("-nomouse"))
 	{
+#if SDLQUAKE == 2
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput (SDL_GRAB_OFF);
+#endif
 		return;
 	}
 
@@ -242,7 +256,11 @@ static void IN_StartupMouse (void)
 	{
 		mouseactivatetoggle = true;
 		mouseactive = true;
+#if SDLQUAKE == 2
+		SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 		SDL_WM_GrabInput (SDL_GRAB_ON);
+#endif
 		SDL_GetRelativeMouseState (NULL, NULL);
 	}
 }
@@ -298,8 +316,10 @@ void IN_Init (void)
 	IN_StartupJoystick ();
 
 	prev_gamekey = Key_IsGameKey();
+#if SDLQUAKE < 2
 	SDL_EnableUNICODE (!prev_gamekey);
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL*2);
+#endif
 }
 
 /*
@@ -331,8 +351,10 @@ void IN_ReInit (void)
 	IN_StartupMouse ();
 
 	prev_gamekey = Key_IsGameKey();
+#if SDLQUAKE < 2
 	SDL_EnableUNICODE (!prev_gamekey);
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL*2);
+#endif
 
 	/* no need for joystick to reinit */
 }
@@ -478,7 +500,11 @@ static void IN_StartupJoystick (void)
 	Con_Printf ("SDL_Joystick: %d devices are reported:\n", joy_available);
 	for (i = 0; i < joy_available; i++)
 	{
+#if SDLQUAKE == 2
+		Con_Printf("#%d: \"%s\"\n", i, SDL_JoystickNameForIndex(i));
+#else
 		Con_Printf("#%d: \"%s\"\n", i, SDL_JoystickName(i));
+#endif
 	}
 
 	trackballactive = true;
@@ -528,7 +554,11 @@ static void IN_Callback_JoyIndex (cvar_t *var)
 		{
 			int numaxes, numbtns, numballs, numhats;
 			Con_Printf("joystick open ");
+#if SDLQUAKE == 2
+			Con_Printf("#%d: \"%s\"\n", idx, SDL_JoystickNameForIndex(idx));
+#else
 			Con_Printf("#%d: \"%s\"\n", idx, SDL_JoystickName(idx));
+#endif
 			numaxes = SDL_JoystickNumAxes(joy_id);
 			numbtns = SDL_JoystickNumButtons(joy_id);
 			numballs= SDL_JoystickNumBalls(joy_id);
@@ -819,13 +849,28 @@ void IN_SendKeyEvents (void)
 	if ((gamekey = Key_IsGameKey()) != prev_gamekey)
 	{
 		prev_gamekey = gamekey;
+#if SDLQUAKE < 2
 		SDL_EnableUNICODE(!gamekey);
+#endif
 	}
 
 	while (SDL_PollEvent(&event))
 	{
 		switch (event.type)
 		{
+#if SDLQUAKE == 2
+		case SDL_WINDOWEVENT:
+			switch (event.window.event)
+			{
+			case SDL_WINDOWEVENT_FOCUS_GAINED:
+				S_UnblockSound();
+				break;
+			case SDL_WINDOWEVENT_FOCUS_LOST:
+				S_BlockSound();
+				break;
+			}
+			break;
+#else
 		case SDL_ACTIVEEVENT:
 			if (event.active.state & (SDL_APPINPUTFOCUS|SDL_APPACTIVE))
 			{
@@ -834,6 +879,7 @@ void IN_SendKeyEvents (void)
 				else	S_BlockSound();
 			}
 			break;
+#endif
 
 		case SDL_KEYDOWN:
 			if ((event.key.keysym.sym == SDLK_RETURN) &&
@@ -851,8 +897,12 @@ void IN_SendKeyEvents (void)
 			if ((event.key.keysym.sym == SDLK_g) &&
 			    (event.key.keysym.mod & KMOD_CTRL))
 			{
+#if SDLQUAKE == 2
+				SDL_SetRelativeMouseMode(!SDL_GetRelativeMouseMode());
+#else
 				SDL_WM_GrabInput((SDL_WM_GrabInput (SDL_GRAB_QUERY) == SDL_GRAB_ON) ?
 									  SDL_GRAB_OFF : SDL_GRAB_ON);
+#endif
 				break;
 			}
 		/* fallthrough */
@@ -861,6 +911,7 @@ void IN_SendKeyEvents (void)
 			state = event.key.state;
 			modstate = SDL_GetModState();
 
+#if SDLQUAKE < 2
 			if (event.key.keysym.unicode != 0)
 			{
 				if ((event.key.keysym.unicode & 0xFF80) == 0)
@@ -888,6 +939,7 @@ void IN_SendKeyEvents (void)
 				/* else: it's an international character */
 			}
 			/*printf("You pressed %s (%d) (%c)\n", SDL_GetKeyName(sym), sym, sym);*/
+#endif
 
 			switch (sym)
 			{
@@ -933,7 +985,9 @@ void IN_SendKeyEvents (void)
 			case SDLK_F12:
 				sym = K_F12;
 				break;
+#if SDLQUAKE < 2
 			case SDLK_BREAK:
+#endif
 			case SDLK_PAUSE:
 				sym = K_PAUSE;
 				break;
@@ -976,61 +1030,110 @@ void IN_SendKeyEvents (void)
 			case SDLK_LALT:
 				sym = K_ALT;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_RGUI:
+			case SDLK_LGUI:
+#else
 			case SDLK_RMETA:
 			case SDLK_LMETA:
+#endif
 				sym = K_COMMAND;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_NUMLOCKCLEAR:
+#else
 			case SDLK_NUMLOCK:
+#endif
 				if (gamekey)
 					sym = K_KP_NUMLOCK;
 				else	sym = 0;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_0:
+#else
 			case SDLK_KP0:
+#endif
 				if (gamekey)
 					sym = K_KP_INS;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_0 : K_INS;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_1:
+#else
 			case SDLK_KP1:
+#endif
 				if (gamekey)
 					sym = K_KP_END;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_1 : K_END;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_2:
+#else
 			case SDLK_KP2:
+#endif
 				if (gamekey)
 					sym = K_KP_DOWNARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_2 : K_DOWNARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_3:
+#else
 			case SDLK_KP3:
+#endif
 				if (gamekey)
 					sym = K_KP_PGDN;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_3 : K_PGDN;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_4:
+#else
 			case SDLK_KP4:
+#endif
 				if (gamekey)
 					sym = K_KP_LEFTARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_4 : K_LEFTARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_5:
+#else
 			case SDLK_KP5:
+#endif
 				if (gamekey)
 					sym = K_KP_5;
 				else	sym = SDLK_5;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_6:
+#else
 			case SDLK_KP6:
+#endif
 				if (gamekey)
 					sym = K_KP_RIGHTARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_6 : K_RIGHTARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_7:
+#else
 			case SDLK_KP7:
+#endif
 				if (gamekey)
 					sym = K_KP_HOME;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_7 : K_HOME;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_8:
+#else
 			case SDLK_KP8:
+#endif
 				if (gamekey)
 					sym = K_KP_UPARROW;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_8 : K_UPARROW;
 				break;
+#if SDLQUAKE == 2
+			case SDLK_KP_9:
+#else
 			case SDLK_KP9:
+#endif
 				if (gamekey)
 					sym = K_KP_PGUP;
 				else	sym = (modstate & KMOD_NUM) ? SDLK_9 : K_PGUP;
@@ -1070,15 +1173,19 @@ void IN_SendKeyEvents (void)
 					sym = 0;
 				else	sym = SDLK_EQUALS;
 				break;
-			case 178: /* the '²' key */
+			case 178: /* the 'ï¿½' key */
 				sym = '~';
 				break;
 			default:
+#if SDLQUAKE == 2
+				if (sym > 255)
+#else
 			/* If we are not directly handled and still above 255,
 			 * just force it to 0. kill unsupported international
 			 * characters, too.  */
 				if ((sym >= SDLK_WORLD_0 && sym <= SDLK_WORLD_95) ||
 									sym > 255)
+#endif
 					sym = 0;
 				break;
 			}
@@ -1100,6 +1207,15 @@ void IN_SendKeyEvents (void)
 			Key_Event(buttonremap[event.button.button - 1], event.button.state == SDL_PRESSED);
 			break;
 
+#if SDLQUAKE == 2
+		case SDL_MOUSEWHEEL:
+			if (!mouseactive || in_mode_set)
+				break;
+			Key_Event( (event.wheel.y > 0 ? K_MWHEELUP : K_MWHEELDOWN), true);
+			Key_Event( (event.wheel.y > 0 ? K_MWHEELUP : K_MWHEELDOWN), false);
+			break;
+#endif
+
 		case SDL_JOYBUTTONDOWN:
 		case SDL_JOYBUTTONUP:
 			if (in_mode_set)
diff --git a/engine/h2shared/sdl_inc.h b/engine/h2shared/sdl_inc.h
index a54999a..dc0222b 100644
--- a/engine/h2shared/sdl_inc.h
+++ b/engine/h2shared/sdl_inc.h
@@ -25,12 +25,16 @@
 
 #if !defined(SDLQUAKE)
 #error "SDLQUAKE must be defined in order to use sdl_inc.h"
+#elif ((SDLQUAKE-0) < 1)
+#error "SDLQUAKE defined as an invalid value"
 #endif	/* SDLQUAKE */
 
-#if defined(SDL_FRAMEWORK) || defined(NO_SDL_CONFIG)
+#if !(defined(SDL_FRAMEWORK) || defined(NO_SDL_CONFIG))
+#include "SDL.h"
+#elif (SDLQUAKE == 1)
 #include <SDL/SDL.h>
 #else
-#include "SDL.h"
+#include <SDL2/SDL.h>
 #endif
 
 /* =================================================================
@@ -53,14 +57,20 @@ hence the SDL_NEW_VERSION_REJECT macro below.
 
 #if SDL_VERSION_ATLEAST(1,3,0)
 
+#if (SDLQUAKE == 1)
+#error "SDLQUAKE defined as 1, but SDL version >= 2"
+#endif
 #define SDL_MIN_X	2
 #define SDL_MIN_Y	0
-#define SDL_MIN_Z	0
+#define SDL_MIN_Z	5 /* vid_sdl.c requires 2.0.5 or newer */
 
 #else	/* SDL-1.2.x */
 
 #define SDL_NEW_VERSION_REJECT	(SDL_VERSIONNUM(1,3,0))	/* reject 1.3.0 and newer at runtime. */
 
+#if (SDLQUAKE > 1)
+#error "SDLQUAKE defined as 2, but SDL version < 2."
+#endif
 #define SDL_MIN_X	1
 #define SDL_MIN_Y	2
 
diff --git a/engine/h2shared/snd_sdl.c b/engine/h2shared/snd_sdl.c
index 26742cc..be70a2c 100644
--- a/engine/h2shared/snd_sdl.c
+++ b/engine/h2shared/snd_sdl.c
@@ -156,8 +156,18 @@ static qboolean S_SDL_Init (dma_t *dma)
 
 	Con_Printf ("SDL audio spec  : %d Hz, %d samples, %d channels\n",
 			obtained.freq, obtained.samples, obtained.channels);
+#if (SDLQUAKE > 1)
+	{
+		const char *driver = SDL_GetCurrentAudioDriver();
+		const char *device = SDL_GetAudioDeviceName(0, SDL_FALSE);
+		q_snprintf(drivername, sizeof(drivername), "%s - %s",
+			driver != NULL ? driver : "(UNKNOWN)",
+			device != NULL ? device : "(UNKNOWN)");
+	}
+#else
 	if (SDL_AudioDriverName(drivername, sizeof(drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
+#endif
 	buffersize = shm->samples * (shm->samplebits / 8);
 	Con_Printf ("SDL audio driver: %s, %d bytes buffer\n", drivername, buffersize);
 
diff --git a/engine/h2shared/vid_sdl.c b/engine/h2shared/vid_sdl.c
index 32bd3a5..6c5c060 100644
--- a/engine/h2shared/vid_sdl.c
+++ b/engine/h2shared/vid_sdl.c
@@ -61,6 +61,12 @@ static int	num_fmodes;
 static int	num_wmodes;
 static int	*nummodes;
 //static int	bpp = 8;
+#if (SDLQUAKE > 1)
+static SDL_Window	*window;
+static SDL_Renderer	*renderer;
+static SDL_Texture	*screen_tex;
+static SDL_Surface	*tex_surface;
+#endif
 static SDL_Surface	*screen;
 static qboolean	vid_menu_fs;
 static qboolean	fs_toggle_works = true;
@@ -146,12 +152,20 @@ static void VID_MenuKey (int key);
 
 qboolean VID_HasMouseOrInputFocus (void)
 {
+#if (SDLQUAKE > 1)
+	return (SDL_GetWindowFlags(window) & (SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_INPUT_FOCUS)) != 0;
+#else
 	return (SDL_GetAppState() & (SDL_APPMOUSEFOCUS | SDL_APPINPUTFOCUS)) != 0;
+#endif
 }
 
 qboolean VID_IsMinimized (void)
 {
+#if (SDLQUAKE > 1)
+	return !(SDL_GetWindowFlags(window) & SDL_WINDOW_SHOWN);
+#else
 	return !(SDL_GetAppState() & SDL_APPACTIVE);
+#endif
 }
 
 
@@ -262,16 +276,29 @@ static void VID_SetIcon (void)
 	if (icon == NULL)
 		return;
 
+#if SDLQUAKE == 1
 	SDL_SetColorKey(icon, SDL_SRCCOLORKEY, 0);
+#else
+	SDL_SetColorKey(icon, SDL_TRUE, 0);
+#endif
 
 	color.r = 255;
 	color.g = 255;
 	color.b = 255;
+
+#if SDLQUAKE == 1
 	SDL_SetColors(icon, &color, 0, 1);	/* just in case */
+#else
+	SDL_SetPaletteColors(icon->format->palette, &color, 0, 1);
+#endif
 	color.r = 192;
 	color.g = 0;
 	color.b = 0;
+#if SDLQUAKE == 1
 	SDL_SetColors(icon, &color, 1, 1);
+#else
+	SDL_SetPaletteColors(icon->format->palette, &color, 1, 1);
+#endif
 
 	ptr = (Uint8 *)icon->pixels;
 	/* one bit represents a pixel, black or white:  each
@@ -285,8 +312,13 @@ static void VID_SetIcon (void)
 		}
 	}
 
+#if SDLQUAKE == 1
 	SDL_WM_SetIcon(icon, NULL);
+#else
+	SDL_SetWindowIcon(window, icon);
+#endif
 	SDL_FreeSurface(icon);
+
 #endif /* !OSX */
 }
 
@@ -304,11 +336,69 @@ static int sort_modes (const void *arg1, const void *arg2)
 	//	return a2->w - a1->w;	// highres-to-lowres
 }
 
-static void VID_PrepareModes (SDL_Rect **sdl_modes)
+static void VID_PrepareModes (void)
 {
 	int	i, j;
 	qboolean	have_mem, is_multiple;
+	SDL_Rect	**sdl_modes;
 	SDL_Rect	**cpy_modes;
+#if SDLQUAKE == 2
+	int k;
+	SDL_DisplayMode	mode;
+	SDL_Rect	mode_rects[MAX_MODE_LIST];
+	SDL_Rect	*ptr_array[MAX_MODE_LIST + 1];
+#endif
+
+#if SDLQUAKE == 2
+	// SDL2 does not have a function to get the full modelist, so we must build it manually.
+
+	num_fmodes = 0;
+
+	// Fill the list with all modes supported by the first display.
+	for (i = 0; i < SDL_GetNumDisplayModes(0) && i < MAX_MODE_LIST; i++)
+	{
+		SDL_GetDisplayMode(0, i, &mode);
+		mode_rects[num_fmodes].x = 0;
+		mode_rects[num_fmodes].y = 0;
+		mode_rects[num_fmodes].w = mode.w;
+		mode_rects[num_fmodes].h = mode.h;
+		num_fmodes++;
+	}
+
+	// Check the other displays and add any modes that aren't already in the list
+	for (i = 1; i < SDL_GetNumVideoDisplays(); i++)
+		for (j = 0; j < SDL_GetNumDisplayModes(i) && num_fmodes < MAX_MODE_LIST; j++)
+		{
+			SDL_GetDisplayMode(i, j, &mode);
+			mode_rects[num_fmodes].x = 0;
+			mode_rects[num_fmodes].y = 0;
+			mode_rects[num_fmodes].w = mode.w;
+			mode_rects[num_fmodes].h = mode.h;
+			num_fmodes++;
+
+			for (k = 0; k < num_fmodes; k++)
+			{
+				if (mode.w == mode_rects[k].w && mode.h == mode_rects[k].h)
+				{
+					num_fmodes--;
+					break;
+				}
+			}
+		}
+
+	if (num_fmodes > 0)
+	{
+		for (i = 0; i < num_fmodes; i++)
+			ptr_array[i] = &mode_rects[i];
+		ptr_array[num_fmodes] = NULL;
+		sdl_modes = ptr_array;
+	}
+	else
+		sdl_modes = NULL;
+#else
+	// retrieve the list of fullscreen modes
+	sdl_modes = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	num_fmodes = 0;
 	num_wmodes = 0;
@@ -507,9 +597,116 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 {
 	Uint32 flags;
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int format;
+	void *pixels;
+	int pitch;
+#endif
 
 	in_mode_set = true;
 
+#if SDLQUAKE == 2
+	if (window)
+	{
+		SDL_FreeSurface(screen);
+		screen = NULL;
+		SDL_FreeSurface(tex_surface);
+		tex_surface = NULL;
+		SDL_DestroyTexture(screen_tex);
+		screen_tex = NULL;
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+	}
+
+	flags = 0;
+	window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, flags);
+
+	if (!window)
+		return false;
+
+	if (vid_config_fscr.integer)
+	{
+		flags = SDL_WINDOW_FULLSCREEN;
+
+		// Try to check the desktop resolution. If it matches the window size, use a borderless window
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+
+	SDL_SetWindowFullscreen(window, flags);
+
+	VID_SetIcon();
+	SDL_SetWindowTitle(window, WM_TITLEBAR_TEXT);
+
+	renderer = SDL_CreateRenderer(window, -1, 0);
+	if (!renderer)
+	{
+		SDL_DestroyWindow(window);
+		window = NULL;
+		return false;
+	}
+
+	format = SDL_GetWindowPixelFormat(window);
+	if (format == SDL_PIXELFORMAT_UNKNOWN)
+		format = SDL_PIXELFORMAT_RGBA32;
+	screen_tex = SDL_CreateTexture(renderer, format, SDL_TEXTUREACCESS_STREAMING, modelist[modenum].width, modelist[modenum].height);
+	if (!screen_tex)
+	{
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+		return false;
+	}
+
+	// Create a "fake" surface that we can redirect to the texture memory when we lock it.
+	SDL_LockTexture(screen_tex, NULL, &pixels, &pitch);
+	tex_surface = SDL_CreateRGBSurfaceWithFormatFrom(pixels, modelist[modenum].width, modelist[modenum].height, SDL_BITSPERPIXEL(format), pitch, format);
+	SDL_UnlockTexture(screen_tex);
+
+	screen = SDL_CreateRGBSurface(0, modelist[modenum].width, modelist[modenum].height, 8, 0, 0, 0, 0);
+
+	if (!tex_surface || !screen)
+	{
+		if (tex_surface)
+		{
+			SDL_FreeSurface(tex_surface);
+			tex_surface = NULL;
+		}
+		if (screen)
+		{
+			SDL_FreeSurface(screen);
+			screen = NULL;	
+		}
+
+		SDL_DestroyTexture(screen_tex);
+		screen_tex = NULL;
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+
+		return false;
+	}
+
+	tex_surface->pixels = NULL;
+	is_fullscreen = (SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP)) ? 1 : 0;
+#else
 	if (screen)
 		SDL_FreeSurface(screen);
 
@@ -524,6 +721,10 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 	if (!screen)
 		return false;
 
+	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
+#endif
+
 	// initial success. adjust vid vars.
 	vid.height = vid.conheight = modelist[modenum].height;
 	vid.width = vid.conwidth = modelist[modenum].width;
@@ -539,7 +740,6 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 
 	// real success. set vid_modenum properly.
 	vid_modenum = modenum;
-	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
 	modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 	Cvar_SetValueQuick (&vid_config_swx, modelist[vid_modenum].width);
 	Cvar_SetValueQuick (&vid_config_swy, modelist[vid_modenum].height);
@@ -551,8 +751,6 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 
 	VID_SetPalette (palette);
 
-	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
-
 	Con_SafePrintf ("Video Mode: %ux%ux%d\n", vid.width, vid.height, modelist[modenum].bpp);
 
 	in_mode_set = false;
@@ -666,7 +864,11 @@ void VID_SetPalette (const unsigned char *palette)
 		colors[i].b = *palette++;
 	}
 
+#if SDLQUAKE == 2
+	SDL_SetPaletteColors(screen->format->palette, colors, 0, 256);
+#else
 	SDL_SetColors(screen, colors, 0, 256);
+#endif
 }
 
 
@@ -684,7 +886,6 @@ VID_Init
 void VID_Init (const unsigned char *palette)
 {
 	int		width, height, i, temp;
-	SDL_Rect	**enumlist;
 	const char	*read_vars[] = {
 				"vid_config_fscr",
 				"vid_config_swx",
@@ -715,10 +916,8 @@ void VID_Init (const unsigned char *palette)
 			Sys_Error("Couldn't init video: %s", SDL_GetError());
 	}
 
-	// retrieve the list of fullscreen modes
-	enumlist = SDL_ListModes(NULL, SDL_SWSURFACE|SDL_HWPALETTE|SDL_FULLSCREEN);
 	// prepare the modelists, find the actual modenum for vid_default
-	VID_PrepareModes(enumlist);
+	VID_PrepareModes();
 
 	// set vid_mode to our safe default first
 	Cvar_SetValueQuick (&vid_mode, vid_default);
@@ -842,12 +1041,48 @@ FlipScreen
 */
 static void FlipScreen (vrect_t *rects)
 {
+#if SDLQUAKE == 2
+	vrect_t *orig_rects = rects;
+	SDL_Rect sdl_rect;
+	int pitch = 0;
+
+	SDL_LockTexture(screen_tex, NULL, &tex_surface->pixels, &pitch);
+#endif
+
 	while (rects)
 	{
+#if SDLQUAKE == 2
+		sdl_rect.x = rects->x;
+		sdl_rect.y = rects->y;
+		sdl_rect.w = rects->width;
+		sdl_rect.h = rects->height;
+
+		SDL_BlitSurface(screen, &sdl_rect, tex_surface, &sdl_rect);
+#else
 		SDL_UpdateRect (screen, rects->x, rects->y, rects->width,
 				rects->height);
+#endif
+		rects = rects->pnext;
+	}
+
+#if SDLQUAKE == 2
+	SDL_UnlockTexture(screen_tex);
+	tex_surface->pixels = NULL;
+
+	rects = orig_rects;
+	while (rects)
+	{
+		sdl_rect.x = rects->x;
+		sdl_rect.y = rects->y;
+		sdl_rect.w = rects->width;
+		sdl_rect.h = rects->height;
+
+		SDL_RenderCopy(renderer, screen_tex, &sdl_rect, &sdl_rect);
 		rects = rects->pnext;
 	}
+
+	SDL_RenderPresent(renderer);
+#endif
 }
 
 void VID_Update (vrect_t *rects)
@@ -910,12 +1145,32 @@ D_EndDirectRect
 */
 void D_EndDirectRect (int x, int y, int width, int height)
 {
+#if SDLQUAKE == 2
+	SDL_Rect sdl_rect;
+	int pitch;
+#endif
+
 //	these bits from quakeforge
 	if (!screen)
 		return;
 	if (x < 0)
 		x = screen->w + x - 1;
+
+#if SDLQUAKE == 2
+	sdl_rect.x = x;
+	sdl_rect.y = y;
+	sdl_rect.w = width;
+	sdl_rect.h = height;
+
+	SDL_LockTexture(screen_tex, NULL, &tex_surface->pixels, &pitch);
+	SDL_BlitSurface(screen, &sdl_rect, tex_surface, &sdl_rect);
+	SDL_UnlockTexture(screen_tex);
+	tex_surface->pixels = NULL;
+	SDL_RenderCopy(renderer, screen_tex, &sdl_rect, &sdl_rect);
+	SDL_RenderPresent(renderer);
+#else
 	SDL_UpdateRect (screen, x, y, width, height);
+#endif
 }
 
 
@@ -1031,19 +1286,61 @@ extern qboolean menu_disabled_mouse;
 void VID_ToggleFullscreen (void)
 {
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int fullscreen_flag;
+#endif
 
 	if (!fs_toggle_works)
 		return;
 	if (!num_fmodes)
 		return;
+#if SDLQUAKE == 2
+	if (!window)
+#else
 	if (!screen)
+#endif
 		return;
 
 	S_ClearBuffer ();
 
+#if SDLQUAKE == 2
+	is_fullscreen = SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// If we're switching to fullscreen, check to see if our window has the same size as the desktop.
+	// If it does, use a borderless window instead of "real" fullscreen for better wm integration.
+	if (!is_fullscreen)
+	{
+		fullscreen_flag = SDL_WINDOW_FULLSCREEN;
+
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				fullscreen_flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+	else
+		fullscreen_flag = 0;
+
+	if (SDL_SetWindowFullscreen(window, fullscreen_flag) == 0)
+#else
 	if (SDL_WM_ToggleFullScreen(screen) == 1)
+#endif
 	{
+#if SDLQUAKE == 2
+		is_fullscreen = !is_fullscreen;
+#else
 		is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+#endif
 		Cvar_SetValueQuick(&vid_config_fscr, is_fullscreen);
 		modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 		if (is_fullscreen)
@@ -1065,7 +1362,11 @@ void VID_ToggleFullscreen (void)
 	else
 	{
 		fs_toggle_works = false;
+#if SDLQUAKE == 2
+		Con_Printf ("SDL_SetWindowFulscreen failed\n");
+#else
 		Con_Printf ("SDL_WM_ToggleFullScreen failed\n");
+#endif
 	}
 }
 
diff --git a/engine/hexen2/Makefile b/engine/hexen2/Makefile
index 28e84dd..f1225b8 100644
--- a/engine/hexen2/Makefile
+++ b/engine/hexen2/Makefile
@@ -48,8 +48,17 @@ OSLIBS:=$(UHEXEN2_TOP)/oslibs
 
 # X directory
 X11BASE    =/usr/X11R6
+
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 2
+
 # the sdl-config command
+ifeq ($(SDL_API),2)
+SDL_CONFIG =sdl2-config
+else
 SDL_CONFIG =sdl-config
+endif
+
 SDL_CFLAGS = $(shell $(SDL_CONFIG) --cflags 2> /dev/null)
 SDL_LIBS   = $(shell $(SDL_CONFIG) --libs 2> /dev/null)
 
@@ -292,10 +301,17 @@ CPUFLAGS=
 # @rpath can be used when targeting 10.5+
 USE_RPATH=no
 ifeq ($(MACH_TYPE),x86)
+ifeq ($(SDL_API),2)
+# sdl2 needs targetting 10.5+
+# as of v2.0.5, sdl2 targets 10.6+
+CFLAGS  +=-mmacosx-version-min=10.6
+LDFLAGS +=-mmacosx-version-min=10.6
+else
 # x86 requires 10.4.
 CFLAGS  +=-mmacosx-version-min=10.4
 LDFLAGS +=-mmacosx-version-min=10.4
 endif
+endif
 ifeq ($(MACH_TYPE),ppc)
 # require 10.2 for ppc builds (midi_osx.c requirement.)
 CFLAGS  +=-mmacosx-version-min=10.2
@@ -348,7 +364,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 # not relying on sdl-config command and assuming
 # /Library/Frameworks/SDL.framework is available
 SDL_CFLAGS =-D_GNU_SOURCE=1 -D_THREAD_SAFE
@@ -360,7 +376,12 @@ ifneq ($(SDL_FRAMEWORK_PATH),)
 SDL_LIBS  +=-F$(SDL_FRAMEWORK_PATH)
 SDL_CFLAGS+=-F$(SDL_FRAMEWORK_PATH)
 endif
-SDL_LIBS  +=-Wl,-framework,SDL -Wl,-framework,Cocoa
+ifeq ($(SDL_API),2)
+SDL_FRAMEWORK_NAME = SDL2
+else
+SDL_FRAMEWORK_NAME = SDL
+endif
+SDL_LIBS  +=-Wl,-framework,$(SDL_FRAMEWORK_NAME) -Wl,-framework,Cocoa
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -456,7 +477,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -489,8 +510,16 @@ LDFLAGS += -s
 CFLAGS  += -fno-omit-frame-pointer
 endif
 # using SDL for now:
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = -L$(OSLIBS)/os2/SDL/lib -lSDL12
+ifeq ($(SDL_API),2)
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+endif
+
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = -L$(OSLIBS)/os2/$(SDL_DIR)/lib -l$(LIB_SDL)
 USE_SDLCD=yes
 USE_SDLAUDIO=yes
 
@@ -514,7 +543,7 @@ endif
 endif
 
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -839,6 +868,8 @@ ifeq ($(TARGET_OS),morphos)
 
 # MorphOS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -898,7 +929,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -915,6 +946,8 @@ ifeq ($(TARGET_OS),aros)
 
 # AROS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -980,7 +1013,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -1000,6 +1033,8 @@ USE_CLIB2=yes
 
 # Don't use SDL on AmigaOS
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -1082,7 +1117,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -1492,8 +1527,10 @@ SYSOBJ_SOFT_VID:= vid_sdl.o
 SYSOBJ_NET := net_bsd.o net_udp.o
 SYSOBJ_SYS := sys_unix.o
 SYSOBJ_SYS += sys_osx.o
+ifeq ($(SDL_API),1)
 SYSOBJ_SYS += SDLMain.o
 endif
+endif
 ifeq ($(TARGET_OS),aros)
 ifeq ($(USE_SDL),yes)
 SYSOBJ_INPUT := in_sdl.o
diff --git a/engine/hexen2/Makefile.os2 b/engine/hexen2/Makefile.os2
index 4965648..088f479 100644
--- a/engine/hexen2/Makefile.os2
+++ b/engine/hexen2/Makefile.os2
@@ -25,6 +25,9 @@ OSLIBS=$(UHEXEN2_TOP)/oslibs
 
 # GENERAL OPTIONS (customize as required)
 
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 1
+
 # link to the opengl libraries at compile time? (defaults
 # to no, so the binaries will dynamically load the necessary
 # libraries and functions at runtime.)
@@ -124,20 +127,28 @@ USE_CODEC_OPUS=no
 
 NASMFLAGS=-f obj -d__OS2__ -d_NO_PREFIX
 
+!ifeq SDL_API 2
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+!else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+!endif
+
 !ifndef __UNIX__
 INCLUDES+= -I$(OSLIBS)\os2\codecs\include
 CODECLIBS=  $(OSLIBS)\os2\codecs\lib\
-SDL_CFLAGS=-I$(OSLIBS)\os2\SDL\include
-SDL_LIBS = $(OSLIBS)\os2\SDL\lib\SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)\os2\$(SDL_DIR)\include
+SDL_LIBS = $(OSLIBS)\os2\$(SDL_DIR)\lib\$(LIB_SDL).lib
 !else
 INCLUDES+= -I$(OSLIBS)/os2/codecs/include
 CODECLIBS=  $(OSLIBS)/os2/codecs/lib/
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = $(OSLIBS)/os2/SDL/lib/SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = $(OSLIBS)/os2/$(SDL_DIR)/lib/$(LIB_SDL).lib
 !endif
 
 # use SDL for now
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LIBS    += $(SDL_LIBS)
 
diff --git a/engine/hexen2/build_cross_osx.sh b/engine/hexen2/build_cross_osx.sh
index b858d4b..ca42675 100755
--- a/engine/hexen2/build_cross_osx.sh
+++ b/engine/hexen2/build_cross_osx.sh
@@ -20,11 +20,11 @@ AR=powerpc-apple-darwin9-ar
 RANLIB=powerpc-apple-darwin9-ranlib
 LIPO=powerpc-apple-darwin9-lipo
 export PATH CC AS AR RANLIB LIPO
-$MAKE_CMD MACH_TYPE=ppc glh2 $* || exit 1
+$MAKE_CMD MACH_TYPE=ppc glh2 $* SDL_API=1 || exit 1
 powerpc-apple-darwin9-strip -S glhexen2 || exit 1
 mv glhexen2 glhexen2.ppc || exit 1
 $MAKE_CMD distclean
-$MAKE_CMD MACH_TYPE=ppc h2 $* || exit 1
+$MAKE_CMD MACH_TYPE=ppc h2 $* SDL_API=1 || exit 1
 powerpc-apple-darwin9-strip -S hexen2 || exit 1
 mv hexen2 hexen2.ppc || exit 1
 $MAKE_CMD distclean
@@ -37,11 +37,11 @@ AR=i686-apple-darwin9-ar
 RANLIB=i686-apple-darwin9-ranlib
 LIPO=i686-apple-darwin9-lipo
 export PATH CC AS AR RANLIB LIPO
-$MAKE_CMD MACH_TYPE=x86 USE_X86_ASM=no glh2 $* || exit 1
+$MAKE_CMD MACH_TYPE=x86 USE_X86_ASM=no glh2 $* SDL_API=1 || exit 1
 i686-apple-darwin9-strip -S glhexen2 || exit 1
 mv glhexen2 glhexen2.x86 || exit 1
 $MAKE_CMD distclean
-$MAKE_CMD MACH_TYPE=x86 h2 $* || exit 1
+$MAKE_CMD MACH_TYPE=x86 h2 $* SDL_API=1 || exit 1
 i686-apple-darwin9-strip -S hexen2 || exit 1
 mv hexen2 hexen2.x86 || exit 1
 $MAKE_CMD distclean
@@ -54,11 +54,11 @@ AR=x86_64-apple-darwin9-ar
 RANLIB=x86_64-apple-darwin9-ranlib
 LIPO=x86_64-apple-darwin9-lipo
 export PATH CC AS AR RANLIB LIPO
-$MAKE_CMD MACH_TYPE=x86_64 glh2 $* || exit 1
+$MAKE_CMD MACH_TYPE=x86_64 glh2 $* SDL_API=1 || exit 1
 x86_64-apple-darwin9-strip -S glhexen2 || exit 1
 mv glhexen2 glhexen2.x86_64 || exit 1
 $MAKE_CMD distclean
-$MAKE_CMD MACH_TYPE=x86_64 h2 $* || exit 1
+$MAKE_CMD MACH_TYPE=x86_64 h2 $* SDL_API=1 || exit 1
 x86_64-apple-darwin9-strip -S hexen2 || exit 1
 mv hexen2 hexen2.x86_64 || exit 1
 $MAKE_CMD distclean
diff --git a/engine/hexen2/sys_os2.c b/engine/hexen2/sys_os2.c
index e2f961f..2580345 100644
--- a/engine/hexen2/sys_os2.c
+++ b/engine/hexen2/sys_os2.c
@@ -452,8 +452,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexen2/sys_unix.c b/engine/hexen2/sys_unix.c
index cd0dc3c..5ecb727 100644
--- a/engine/hexen2/sys_unix.c
+++ b/engine/hexen2/sys_unix.c
@@ -576,8 +576,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexenworld/client/Makefile b/engine/hexenworld/client/Makefile
index f004324..8e37d36 100644
--- a/engine/hexenworld/client/Makefile
+++ b/engine/hexenworld/client/Makefile
@@ -50,8 +50,17 @@ OSLIBS:=$(UHEXEN2_TOP)/oslibs
 
 # X directory
 X11BASE    =/usr/X11R6
+
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 2
+
 # the sdl-config command
+ifeq ($(SDL_API),2)
+SDL_CONFIG =sdl2-config
+else
 SDL_CONFIG =sdl-config
+endif
+
 SDL_CFLAGS = $(shell $(SDL_CONFIG) --cflags 2> /dev/null)
 SDL_LIBS   = $(shell $(SDL_CONFIG) --libs 2> /dev/null)
 
@@ -253,10 +262,17 @@ CPUFLAGS=
 # @rpath can be used when targeting 10.5+
 USE_RPATH=no
 ifeq ($(MACH_TYPE),x86)
+ifeq ($(SDL_API),2)
+# sdl2 needs targetting 10.5+
+# as of v2.0.5, sdl2 targets 10.6+
+CFLAGS  +=-mmacosx-version-min=10.6
+LDFLAGS +=-mmacosx-version-min=10.6
+else
 # x86 requires 10.4.
 CFLAGS  +=-mmacosx-version-min=10.4
 LDFLAGS +=-mmacosx-version-min=10.4
 endif
+endif
 ifeq ($(MACH_TYPE),ppc)
 # require 10.2 for ppc builds (midi_osx.c requirement.)
 CFLAGS  +=-mmacosx-version-min=10.2
@@ -309,7 +325,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 # not relying on sdl-config command and assuming
 # /Library/Frameworks/SDL.framework is available
 SDL_CFLAGS =-D_GNU_SOURCE=1 -D_THREAD_SAFE
@@ -321,7 +337,12 @@ ifneq ($(SDL_FRAMEWORK_PATH),)
 SDL_LIBS  +=-F$(SDL_FRAMEWORK_PATH)
 SDL_CFLAGS+=-F$(SDL_FRAMEWORK_PATH)
 endif
-SDL_LIBS  +=-Wl,-framework,SDL -Wl,-framework,Cocoa
+ifeq ($(SDL_API),2)
+SDL_FRAMEWORK_NAME = SDL2
+else
+SDL_FRAMEWORK_NAME = SDL
+endif
+SDL_LIBS  +=-Wl,-framework,$(SDL_FRAMEWORK_NAME) -Wl,-framework,Cocoa
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -417,7 +438,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -450,8 +471,16 @@ LDFLAGS += -s
 CFLAGS  += -fno-omit-frame-pointer
 endif
 # using SDL for now:
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = -L$(OSLIBS)/os2/SDL/lib -lSDL12
+ifeq ($(SDL_API),2)
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+endif
+
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = -L$(OSLIBS)/os2/$(SDL_DIR)/lib -l$(LIB_SDL)
 USE_SDLCD=yes
 USE_SDLAUDIO=yes
 
@@ -475,7 +504,7 @@ endif
 endif
 
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -790,6 +819,8 @@ ifeq ($(TARGET_OS),morphos)
 
 # MorphOS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -849,7 +880,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -866,6 +897,8 @@ ifeq ($(TARGET_OS),aros)
 
 # AROS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -931,7 +964,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -951,6 +984,8 @@ USE_CLIB2=yes
 
 # Don't use SDL on AmigaOS
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -1033,7 +1068,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -1423,8 +1458,10 @@ SYSOBJ_GL_VID:= gl_vidsdl.o
 SYSOBJ_SOFT_VID:= vid_sdl.o
 SYSOBJ_SYS := sys_unix.o
 SYSOBJ_SYS += sys_osx.o
+ifeq ($(SDL_API),1)
 SYSOBJ_SYS += SDLMain.o
 endif
+endif
 ifeq ($(TARGET_OS),aros)
 ifeq ($(USE_SDL),yes)
 SYSOBJ_INPUT := in_sdl.o
diff --git a/engine/hexenworld/client/Makefile.os2 b/engine/hexenworld/client/Makefile.os2
index 708230c..c00d35f 100644
--- a/engine/hexenworld/client/Makefile.os2
+++ b/engine/hexenworld/client/Makefile.os2
@@ -29,6 +29,9 @@ OSLIBS=$(UHEXEN2_TOP)/oslibs
 
 # GENERAL OPTIONS (customize as required)
 
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 2
+
 # link to the opengl libraries at compile time? (defaults
 # to no, so the binaries will dynamically load the necessary
 # libraries and functions at runtime.)
@@ -130,20 +133,28 @@ USE_CODEC_OPUS=no
 
 NASMFLAGS=-f obj -d__OS2__ -d_NO_PREFIX
 
+!ifeq SDL_API 2
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+!else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+!endif
+
 !ifndef __UNIX__
 INCLUDES+= -I$(OSLIBS)\os2\codecs\include
 CODECLIBS=  $(OSLIBS)\os2\codecs\lib\
-SDL_CFLAGS=-I$(OSLIBS)\os2\SDL\include
-SDL_LIBS = $(OSLIBS)\os2\SDL\lib\SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)\os2\$(SDL_DIR)\include
+SDL_LIBS = $(OSLIBS)\os2\$(SDL_DIR)\lib\$(LIB_SDL).lib
 !else
 INCLUDES+= -I$(OSLIBS)/os2/codecs/include
 CODECLIBS=  $(OSLIBS)/os2/codecs/lib/
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = $(OSLIBS)/os2/SDL/lib/SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = $(OSLIBS)/os2/$(SDL_DIR)/lib/$(LIB_SDL).lib
 !endif
 
 # use SDL for now
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LIBS    += $(SDL_LIBS)
 
diff --git a/engine/hexenworld/client/build_cross_osx.sh b/engine/hexenworld/client/build_cross_osx.sh
index 9838716..a54c528 100755
--- a/engine/hexenworld/client/build_cross_osx.sh
+++ b/engine/hexenworld/client/build_cross_osx.sh
@@ -20,11 +20,11 @@ AR=powerpc-apple-darwin9-ar
 RANLIB=powerpc-apple-darwin9-ranlib
 LIPO=powerpc-apple-darwin9-lipo
 export PATH CC AS AR RANLIB LIPO
-$MAKE_CMD MACH_TYPE=ppc glhw $* || exit 1
+$MAKE_CMD MACH_TYPE=ppc glhw $* SDL_API=1 || exit 1
 powerpc-apple-darwin9-strip -S glhwcl || exit 1
 mv glhwcl glhwcl.ppc || exit 1
 $MAKE_CMD distclean
-$MAKE_CMD MACH_TYPE=ppc hw $* || exit 1
+$MAKE_CMD MACH_TYPE=ppc hw $* SDL_API=1 || exit 1
 powerpc-apple-darwin9-strip -S hwcl || exit 1
 mv hwcl hwcl.ppc || exit 1
 $MAKE_CMD distclean
@@ -37,11 +37,11 @@ AR=i686-apple-darwin9-ar
 RANLIB=i686-apple-darwin9-ranlib
 LIPO=i686-apple-darwin9-lipo
 export PATH CC AS AR RANLIB LIPO
-$MAKE_CMD MACH_TYPE=x86 USE_X86_ASM=no glhw $* || exit 1
+$MAKE_CMD MACH_TYPE=x86 USE_X86_ASM=no glhw $* SDL_API=1 || exit 1
 i686-apple-darwin9-strip -S glhwcl || exit 1
 mv glhwcl glhwcl.x86 || exit 1
 $MAKE_CMD distclean
-$MAKE_CMD MACH_TYPE=x86 hw $* || exit 1
+$MAKE_CMD MACH_TYPE=x86 hw $* SDL_API=1 || exit 1
 i686-apple-darwin9-strip -S hwcl || exit 1
 mv hwcl hwcl.x86 || exit 1
 $MAKE_CMD distclean
@@ -54,11 +54,11 @@ AR=x86_64-apple-darwin9-ar
 RANLIB=x86_64-apple-darwin9-ranlib
 LIPO=x86_64-apple-darwin9-lipo
 export PATH CC AS AR RANLIB LIPO
-$MAKE_CMD MACH_TYPE=x86_64 glhw $* || exit 1
+$MAKE_CMD MACH_TYPE=x86_64 glhw $* SDL_API=1 || exit 1
 x86_64-apple-darwin9-strip -S glhwcl || exit 1
 mv glhwcl glhwcl.x86_64 || exit 1
 $MAKE_CMD distclean
-$MAKE_CMD MACH_TYPE=x86_64 hw $* || exit 1
+$MAKE_CMD MACH_TYPE=x86_64 hw $* SDL_API=1 || exit 1
 x86_64-apple-darwin9-strip -S hwcl || exit 1
 mv hwcl hwcl.x86_64 || exit 1
 $MAKE_CMD distclean
diff --git a/engine/hexenworld/client/sys_os2.c b/engine/hexenworld/client/sys_os2.c
index a3071d7..7e1bd9c 100644
--- a/engine/hexenworld/client/sys_os2.c
+++ b/engine/hexenworld/client/sys_os2.c
@@ -385,8 +385,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexenworld/client/sys_unix.c b/engine/hexenworld/client/sys_unix.c
index 28dc3b9..d3f3dc9 100644
--- a/engine/hexenworld/client/sys_unix.c
+++ b/engine/hexenworld/client/sys_unix.c
@@ -521,8 +521,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */

