diff -urNp MiniGL~/Build_gcc/makefile MiniGL/Build_gcc/makefile
--- MiniGL~/Build_gcc/makefile	2002-11-30 08:14:20.000000000 +0200
+++ MiniGL/Build_gcc/makefile	2016-07-01 07:11:00.000000000 +0300
@@ -13,17 +13,29 @@
 #
 
 VPATH = ../src/ ../demos
+
 INCLUDE = -I../include
-CFLAGS = $(INCLUDE) -m68060 -D__M68K__ $(DEBUG) $(ADDFLAG) -ffast-math -fomit-frame-pointer
+
 DEBUG = -DNDEBUG
-LIBNAME = ../lib/libmgl.a
 
-DEMOS = GLTest varray warp mtex gears driverinfo
+CFLAGS = -m68060 -D__M68K__ $(DEBUG) $(ADDFLAG) -ffast-math -fomit-frame-pointer
+CFLAGS+= -O3 -DINLINE=__inline
+#CFLAGS+= -g
+CFLAGS+= -noixemul
+CFLAGS+= -Wall -Wno-unused
+CFLAGS+= $(INCLUDE)
+LIBDIR = ../lib
+LIBNAME = $(LIBDIR)/libmgl.a
 
-CC = m68k-amigaos-gcc -O3 -g -DINLINE=__inline
+DEMOS = GLTest varray warp mtex gears driverinfo
+DEBUGLIB= -ldebug
+LDFLAGS = -noixemul
+LDLIBS  = -L$(LIBDIR) -lmgl $(DEBUGLIB) -lm
 
-AR = ar
+CC = m68k-amigaos-gcc
+AR = m68k-amigaos-ar
 RANLIB = m68k-amigaos-ranlib
+MKDIR = mkdir -p
 
 LIBOBJ = context.o vertexbuffer.o draw.o texture.o fog.o \
 	hclip.o init.o glu.o \
@@ -31,79 +43,63 @@ LIBOBJ = context.o vertexbuffer.o draw.o
 	others.o matrix.o
 
 
-DEBUGLIB = -ldebug
-
-EXEOBJ = GLTest.o
-
-all: $(LIBNAME) $(DEMOS)
+all: $(LIBDIR) $(LIBNAME) $(DEMOS)
 
 install:
-		cp ../include/mgl/*.h /usr/os-include/mgl
-		cp ../lib/libmgl.a /usr/m68k-amigaos/lib
+	cp ../include/mgl/*.h /usr/os-include/mgl
+	cp ../lib/libmgl.a /usr/m68k-amigaos/lib
 
 clean:
-		-rm *.o ../lib/libmgl.a
+	$(RM) *.o
+distclean: clean
+	$(RM) $(LIBNAME) $(DEMOS)
 
 lib: $(LIBNAME)
-		@echo "Done"
+	@echo "Done"
 
+$(LIBDIR):
+	$(MKDIR) $(LIBDIR)
+$(LIBNAME): $(LIBDIR) $(LIBOBJ)
+	$(AR) rcs $(LIBNAME) $(LIBOBJ)
+	$(RANLIB) $(LIBNAME)
 
 GLTest: GLTest.o $(LIBNAME)
-		$(CC) -o GLTest $(INCLUDE) GLTest.o -L../lib -lmgl $(DEBUGLIB)
+	$(CC) $(LDFLAGS) -o GLTest GLTest.o $(LDLIBS)
 
 gears: gears.o $(LIBNAME)
-		$(CC) -o gears $(INCLUDE) gears.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy gears ../gears
+	$(CC) $(LDFLAGS) -o gears gears.o $(LDLIBS)
 
 gears_stats: gears_stats.o $(LIBNAME)
-		$(CC) -o gears_stats $(INCLUDE) gears_stats.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy gears_stats ../gears_stats
+	$(CC) $(LDFLAGS) -o gears_stats gears_stats.o $(LDLIBS)
 
 driverinfo: driverinfo.o $(LIBNAME)
-		$(CC) -o driverinfo $(INCLUDE) driverinfo.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy driverinfo ../driverinfo
+	$(CC) $(LDFLAGS) -o driverinfo driverinfo.o $(LDLIBS)
 
 varray_new: varray_new.o $(LIBNAME)
-		$(CC) -o varray_new $(INCLUDE) varray_new.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy varray_new ../varray_new
+	$(CC) $(LDFLAGS) -o varray_new varray_new.o $(LDLIBS)
 
 mtex: mtex.o $(LIBNAME)
-		$(CC) -o mtex $(INCLUDE) mtex.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy mtex ../mtex
+	$(CC) $(LDFLAGS) -o mtex mtex.o $(LDLIBS)
 
 bounce: bounce.o $(LIBNAME)
-		$(CC) -o bounce $(INCLUDE) bounce.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy bounce ../bounce
+	$(CC) $(LDFLAGS) -o bounce bounce.o $(LDLIBS)
 
 smtest: smtest.o $(LIBNAME)
-		$(CC) -o smtest $(INCLUDE) smtest.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy smtest ../smtest
+	$(CC) $(LDFLAGS) -o smtest smtest.o $(LDLIBS)
 
 texsub: texsub.o $(LIBNAME)
-		$(CC) -o texsub $(INCLUDE) texsub.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy texsub ../texsub
-
-../gears: gears.o $(LIBNAME)
-		$(CC) -o gears $(INCLUDE) gears.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy gears ../gears
+	$(CC) $(LDFLAGS) -o texsub texsub.o $(LDLIBS)
 
 warp: warp.o $(LIBNAME)
-		$(CC) -o warp $(INCLUDE) warp.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy warp ../warp
+	$(CC) $(LDFLAGS) -o warp warp.o $(LDLIBS)
 
 rasonly: rasonly.o $(LIBNAME)
-		$(CC) -o rasonly $(INCLUDE) rasonly.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy rasonly ../rasonly
+	$(CC) $(LDFLAGS) -o rasonly rasonly.o $(LDLIBS)
 
 varray: varray.o $(LIBNAME)
-		$(CC) -o varray $(INCLUDE) varray.o -L../lib -lmgl $(DEBUGLIB)
-#		/c/copy varray ../varray
-
-$(LIBNAME):  $(LIBOBJ)
-		$(AR) rcs $(LIBNAME) $(LIBOBJ)
-
+	$(CC) $(LDFLAGS) -o varray varray.o $(LDLIBS)
 
 
 depend:
-		makedepend $(INCLUDE) src/*.c
+	makedepend $(INCLUDE) src/*.c
 
diff -urNp MiniGL~/makefile.vbcc68k MiniGL/makefile.vbcc68k
--- MiniGL~/makefile.vbcc68k	2002-11-30 08:15:32.000000000 +0200
+++ MiniGL/makefile.vbcc68k	2016-08-08 05:55:00.000000000 +0300
@@ -16,38 +16,45 @@
 #
 #
 
-INCLUDE =
+INCLUDE   = -Iinclude
+# -IVBCC_INCLUDES/vincludem68k
 DEBUG =
-
-CFLAGS = -O1 -speed -c99 $(INCLUDE) -cpu=68060 -fpu=68060 $(DEBUG)
-
+CFLAGS    = -O1 -speed -c99 $(INCLUDE) -cpu=68060 -fpu=68060 $(DEBUG)
 OP_CFLAGS = -O2 -speed -c99 $(INCLUDE) -cpu=68060 -fpu=68060 $(DEBUG)
 
-
-LIBS = -lm040 -lmgl -lextra -lcgfx
-LIBNAME = vlibm68k:mgl.lib
+LIBDIR = lib/vbcc
+LIBS = -L$(LIBDIR) -lm040 -lmgl -lextra -lauto
+# -lcgfx
+LIBNAME = $(LIBDIR)/mgl.lib
 DIR = Build
 EXENAME = GLTest
-EXESRC = src/GLTest.c
+EXESRC = src/GLTest.c src/kprintf.c
 
 DEMOS = GLTest warp varray gears mtex driverinfo
 
-CC=vc +m68kdb
-AR=join as
+CC = vc
+# +m68kdb
+MKDIR = mkdir -p
+#MKLIB = join $(LIBOBJ) as $(LIBNAME)
+MKLIB = cat $(LIBOBJ) > $(LIBNAME)
 
-LIBOBJ = $(DIR)/kprintf.o $(DIR)/init.o $(DIR)/glu.o \
+LIBOBJ = $(DIR)/init.o $(DIR)/glu.o \
 $(DIR)/fog.o $(DIR)/others.o $(DIR)/texture.o \
 $(DIR)/context.o $(DIR)/matrix.o $(DIR)/vertexbuffer.o \
 $(DIR)/hclip.o $(DIR)/draw.o \
 $(DIR)/aclip.o $(DIR)/vertexarray.o $(DIR)/vertexelements.o
+#moved kprintf.o to EXE objects
+#$(DIR)/kprintf.o
 
-all: $(LIBNAME) $(DEMOS)
+all: $(LIBDIR) $(LIBNAME) $(DEMOS)
 
 install:
 	copy include/mgl/#?.h vinclude68k:mgl
 
 clean:
-	delete force quiet $(DIR)/#?.o GLtest
+	$(RM) $(DIR)/*.o
+distclean: clean
+	$(RM) $(LIBNAME) $(EXENAME) $(DEMOS)
 
 lib: $(LIBNAME)
 	@echo "Done"
@@ -56,6 +63,13 @@ INCS = src/sysinc.h src/vertexarray.h in
        include/mgl/context.h include/mgl/gl.h include/mgl/log.h \
        include/mgl/matrix.h include/mgl/minigl.h include/mgl/vertexbuffer.h
 
+$(LIBNAME): $(LIBDIR) $(LIBOBJ)
+	$(MKLIB)
+$(LIBDIR):
+	$(MKDIR) $(LIBDIR)
+
+$(EXENAME): $(EXESRC) $(LIBNAME)
+	$(CC) $(CFLAGS) -o $@ $(EXESRC) $(LIBS)
 
 driverinfo: demos/driverinfo.c $(LIBNAME)
 	$(CC) $(CFLAGS) -o driverinfo demos/driverinfo.c $(LIBS)
@@ -79,15 +93,6 @@ rasonly: demos/rasonly.c $(LIBNAME)
 	$(CC) $(CFLAGS) -o rasonly demos/rasonly.c $(LIBS)
 
 
-
-$(LIBNAME): $(LIBOBJ)
-	$(AR) $(LIBNAME) $(LIBOBJ)
-
-$(EXENAME): $(EXESRC) $(LIBNAME)
-	$(CC) $(CFLAGS) -o $@ $(EXESRC) $(LIBS)
-
-
-
 $(DIR)/texture.o: src/texture.c $(INCS)
 	$(CC) $(OP_CFLAGS) -c -o $@ src/texture.c
 
@@ -97,7 +102,7 @@ $(DIR)/matrix.o: src/matrix.c $(INCS)
 $(DIR)/vertexbuffer.o: src/vertexbuffer.c $(INCS)
 	$(CC) $(OP_CFLAGS) -c -o $@ src/vertexbuffer.c 
 
-
 # Implicit rule to build each module of MiniGL (when optimization level is default)
 $(DIR)/%.o : src/%.c $(INCS)
 	$(CC) $(CFLAGS) -c -o $@ $<
+

diff -urNp MiniGL~/include/mgl/config.h MiniGL/include/mgl/config.h
--- MiniGL~/include/mgl/config.h	2002-11-30 08:15:16.000000000 +0200
+++ MiniGL/include/mgl/config.h	2016-04-15 17:55:20.000000000 +0300
@@ -67,7 +67,7 @@
 #define GLNDEBUG 1
 
 // Define if you don't want glGetError functionality
-#define GL_NOERRORCHECK 1
+/*#define GL_NOERRORCHECK 1*/
 
 
 // Define if you don't want to check if the bitmaps allocated for
diff -urNp MiniGL~/include/mgl/gl.h MiniGL/include/mgl/gl.h
--- MiniGL~/include/mgl/gl.h	2002-11-30 08:15:20.000000000 +0200
+++ MiniGL/include/mgl/gl.h	2016-04-15 17:56:10.000000000 +0300
@@ -309,6 +309,13 @@ enum
 	MGL_UNSIGNED_SHORT_4_4_4_4,
 	MGL_FIXPOINTTRANS_HINT,
 	MGL_ARRAY_TRANSFORMATIONS,
+
+	/**/
+	GL_STENCIL_BITS,
+	GL_STENCIL_TEST,
+	GL_KEEP,
+	GL_INCR,
+	GL_STENCIL_BUFFER_BIT,
 };
 
 #define GL_COLOR_BUFFER_BIT     0x00000001
@@ -357,13 +364,16 @@ extern GLcontext mini_CurrentContext;
 
 #ifndef GL_NOERRORCHECK
 	extern int kprintf(char *, ...);
-	#define GLFlagError(context,c,err) while ((c)) {\
+	#define GLFlagError(context,c,err) if ((c)) {\
 		context->CurrentError = err;\
-		kprintf("GLError: %ld at %s:%ld\n", (int)err, __FILE__,(int)__LINE__);\
+	/*	kprintf("GLError: %ld at %s:%ld\n", (int)err, __FILE__,(int)__LINE__);*/\
 		return;\
 	}
 #else
-	#define GLFlagError(context,c,err)
+	#define GLFlagError(context,c,err) if ((c)) {\
+	/*	context->CurrentError = err;*/\
+		return;\
+	}
 #endif
 
 
@@ -378,7 +388,7 @@ extern GLcontext mini_CurrentContext;
 
 void        GLActiveTextureARB(GLcontext context, GLenum unit);
 void        GLMultiTexCoord2fARB(GLcontext context, GLenum unit, GLfloat s, GLfloat t);
-void        GLMultiTexCoord2fvARB(GLcontext context, GLenum unit, GLfloat *v);
+void        GLMultiTexCoord2fvARB(GLcontext context, GLenum unit, const GLfloat *v);
 
 void MGLDrawMultitexBuffer (GLcontext context, GLenum BSrc, GLenum BDst, GLenum TexEnv);
 
@@ -393,14 +403,14 @@ void        GLBlendFunc(GLcontext contex
 void        GLClear(GLcontext context, GLbitfield mask);
 void        GLClearColor(GLcontext context, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
 void        GLClearDepth(GLcontext context, GLclampd depth);
-void        GLColor3fv(GLcontext context, GLfloat *v);
-void        GLColor3ubv(GLcontext context, GLubyte *v);
+void        GLColor3fv(GLcontext context, const GLfloat *v);
+void        GLColor3ubv(GLcontext context, const GLubyte *v);
 void        GLColor4f(GLcontext context, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
-void        GLColor4fv(GLcontext context, GLfloat *v);
+void        GLColor4fv(GLcontext context, const GLfloat *v);
 void        GLColor4ub(GLcontext context, GLubyte red, GLubyte green, GLubyte blue, GLubyte alhpa);
-void        GLColor4ubv(GLcontext context, GLubyte *v);
+void        GLColor4ubv(GLcontext context, const GLubyte *v);
 //void        GLColorPointer(GLcontext context, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
-void        GLColorTable(GLcontext context, GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, GLvoid *data);
+void        GLColorTable(GLcontext context, GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, const GLvoid *data);
 void        GLCullFace(GLcontext context, GLenum mode);
 void        GLDeleteTextures(GLcontext context, GLsizei n, const GLuint *textures);
 void        GLDepthFunc(GLcontext context, GLenum func);
@@ -421,7 +431,7 @@ void        GLEnd(GLcontext context);
 void        GLFinish(GLcontext context);
 void        GLFlush(GLcontext context);
 void        GLFogf(GLcontext context, GLenum pname, GLfloat param);
-void        GLFogfv(GLcontext context, GLenum pname, GLfloat *param);
+void        GLFogfv(GLcontext context, GLenum pname, const GLfloat *param);
 void        GLFrontFace(GLcontext context, GLenum mode);
 void        GLFrustum(GLcontext context, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
 void        GLGenTextures(GLcontext context, GLsizei n, GLuint *textures);
@@ -482,9 +492,9 @@ void        GLScalef(GLcontext context, 
 void        GLScissor(GLcontext context, GLint x, GLint y, GLsizei width, GLsizei height);
 void        GLShadeModel(GLcontext context, GLenum mode);
 void        GLTexCoord2f(GLcontext context, GLfloat s, GLfloat t);
-void        GLTexCoord2fv(GLcontext context, GLfloat *v);
+void        GLTexCoord2fv(GLcontext context, const GLfloat *v);
 void        GLTexCoord4f(GLcontext context, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
-void        GLTexCoord4fv(GLcontext context, GLfloat *v);
+void        GLTexCoord4fv(GLcontext context, const GLfloat *v);
 //void        GLTexCoordPointer(GLcontext context, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 void        GLTexEnvi(GLcontext context, GLenum target, GLenum pname, GLint param);
 void        GLTexGeni(GLcontext context, GLenum coord, GLenum mode, GLenum map);
@@ -496,9 +506,9 @@ void        GLTranslatef(GLcontext conte
 void        GLVertex4f(GLcontext context, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
 void        GLVertex2f(GLcontext context, GLfloat x, GLfloat y);
 
-void        GLVertex4fv(GLcontext context, GLfloat *v);
-void        GLVertex3fv(GLcontext context, GLfloat *v);
-void        GLVertex2fv(GLcontext context, GLfloat *v);
+void        GLVertex4fv(GLcontext context, const GLfloat *v);
+void        GLVertex3fv(GLcontext context, const GLfloat *v);
+void        GLVertex2fv(GLcontext context, const GLfloat *v);
 
 //void        GLVertexPointer(GLcontext context, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 void        GLViewport(GLcontext context, GLint x, GLint y, GLsizei width, GLsizei height);
@@ -534,7 +544,7 @@ void        MGLSwitchBuffer(GLcontext co
 void        MGLSwitchDisplay(GLcontext context);
 void        MGLTexMemStat(GLcontext context, GLint *Current, GLint *Peak);
 void        MGLUnlockDisplay(GLcontext context);
-void        MGLWriteShotPPM(GLcontext context, char *filename);
+void        MGLWriteShotPPM(GLcontext context, const char *filename);
 GLboolean        MGLInit(void);
 void        MGLTerm(void);
 
@@ -887,6 +897,10 @@ void        GLDrawArrays(GLcontext conte
 #define gluLookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz) GLULookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz);
 #define gluPerspective(fovy, aspect, znear, zfar) GLUPerspective(fovy, aspect, znear, zfar);
 
+/* dummies (so that uhexen2 code builds..) */
+#define glStencilFunc(f,r,m) do{}while(0)
+#define glStencilOp(f,zf,zp) do{}while(0)
+#define glClearStencil(s)    do{}while(0)
 
 #endif // USE_MGLAPI not defined
 
diff -urNp MiniGL~/include/mgl/mglmacros.h MiniGL/include/mgl/mglmacros.h
--- MiniGL~/include/mgl/mglmacros.h	2002-11-30 08:15:22.000000000 +0200
+++ MiniGL/include/mgl/mglmacros.h	2016-04-15 17:55:10.000000000 +0300
@@ -387,4 +387,4 @@ CC->CurrentPointSize = (GLfloat)(size);}
 
 #endif
 
-#endif
\ No newline at end of file
+#endif
diff -urNp MiniGL~/include/mgl/minigl.h MiniGL/include/mgl/minigl.h
--- MiniGL~/include/mgl/minigl.h	2002-11-30 08:15:22.000000000 +0200
+++ MiniGL/include/mgl/minigl.h	2016-04-15 17:56:10.000000000 +0300
@@ -32,12 +32,12 @@ MGLAPI void   glPointSize(GLfloat s)
 	 CC->CurrentPointSize = s;
 }
 
-MGLAPI void   glTexEnviv(GLenum target, GLenum pname, GLint *param)
+MGLAPI void   glTexEnviv(GLenum target, GLenum pname, const GLint *param)
 {
 	 GLTexEnvi(CC, target, pname, *(param)) ;
 }
 
-MGLAPI void   glTexEnvfv(GLenum target, GLenum pname, GLfloat *param)
+MGLAPI void   glTexEnvfv(GLenum target, GLenum pname, const GLfloat *param)
 {
 	GLTexEnvi(CC, target, pname, (GLint)(*(param))) ;
 }
@@ -111,7 +111,7 @@ MGLAPI void glColor3f(GLfloat red, GLflo
 	CC->UpdateCurrentColor = GL_TRUE;
 }
 
-MGLAPI void glColor3fv(GLfloat *v)
+MGLAPI void glColor3fv(const GLfloat *v)
 {
 	GLfloat red, green, blue;
 
@@ -134,7 +134,7 @@ MGLAPI void glColor3fv(GLfloat *v)
 	CC->UpdateCurrentColor = GL_TRUE;
 }
 
-MGLAPI void glColor3ubv(GLubyte *v)
+MGLAPI void glColor3ubv(const GLubyte *v)
 {
 	const W3D_Float f = 1.f/255.f;
 	CC->CurrentColor.r = (W3D_Float)v[0]*f;
@@ -174,7 +174,7 @@ MGLAPI void glColor4f(GLfloat red, GLflo
 	CC->UpdateCurrentColor = GL_TRUE;
 }
 
-MGLAPI void glColor4fv(GLfloat *v)
+MGLAPI void glColor4fv(const GLfloat *v)
 {
 	GLfloat red, green, blue, alpha;
 
@@ -210,7 +210,7 @@ MGLAPI void glColor4ub(GLubyte red, GLub
 	CC->UpdateCurrentColor = GL_TRUE;
 }
 
-MGLAPI void glColor4ubv(GLubyte *v)
+MGLAPI void glColor4ubv(const GLubyte *v)
 {
 	const W3D_Float f = 1.f/255.f;
 	CC->CurrentColor.r = (W3D_Float)v[0]*f;
@@ -285,7 +285,7 @@ MGLAPI void glFogi(GLenum pname, GLint p
 	GLFogf(CC, pname, (GLfloat)param);
 }
 
-MGLAPI void glFogfv(GLenum pname, GLfloat *param)
+MGLAPI void glFogfv(GLenum pname, const GLfloat *param)
 {
 	GLFogfv(CC, pname, param);
 }
@@ -443,7 +443,7 @@ MGLAPI void glTexCoord2f(GLfloat s, GLfl
 	#undef thisvertex
 }
 
-MGLAPI void glTexCoord2fv(GLfloat *v)
+MGLAPI void glTexCoord2fv(const GLfloat *v)
 {
 	#define thisvertex CC->VertexBuffer[CC->VertexBufferPointer]
 
@@ -466,7 +466,7 @@ MGLAPI void glTexCoord4f(GLfloat s, GLfl
 	#undef thisvertex
 }
 
-MGLAPI void glTexCoord4fv(GLfloat *v)
+MGLAPI void glTexCoord4fv(const GLfloat *v)
 {
 	#define thisvertex CC->VertexBuffer[CC->VertexBufferPointer]
 
@@ -548,7 +548,7 @@ MGLAPI void glVertex2f(GLfloat x, GLfloa
 	#undef thisvertex
 }
 
-MGLAPI void glVertex2fv(GLfloat *v)
+MGLAPI void glVertex2fv(const GLfloat *v)
 {
 	#define thisvertex CC->VertexBuffer[CC->VertexBufferPointer]
 
@@ -596,7 +596,7 @@ MGLAPI void glVertex3f(GLfloat x, GLfloa
 	#undef thisvertex
 }
 
-MGLAPI void glVertex3fv(GLfloat *v)
+MGLAPI void glVertex3fv(const GLfloat *v)
 {
 	#define thisvertex CC->VertexBuffer[CC->VertexBufferPointer]
 
@@ -644,7 +644,7 @@ MGLAPI void glVertex4f(GLfloat x, GLfloa
 	#undef thisvertex
 }
 
-MGLAPI void glVertex4fv(GLfloat *v)
+MGLAPI void glVertex4fv(const GLfloat *v)
 {
 	#define thisvertex CC->VertexBuffer[CC->VertexBufferPointer]
 
@@ -773,7 +773,7 @@ MGLAPI void mglUnlockDisplay(void)
 	MGLUnlockDisplay(CC);
 }
 
-MGLAPI void mglWriteShotPPM(char *filename)
+MGLAPI void mglWriteShotPPM(const char *filename)
 {
 	MGLWriteShotPPM(CC, filename);
 }
@@ -788,12 +788,12 @@ MGLAPI void mglSetZOffset(GLfloat offset
 	MGLSetZOffset(CC, offset);
 }
 
-MGLAPI void glColorTable(GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, GLvoid *data)
+MGLAPI void glColorTable(GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, const GLvoid *data)
 {
 	GLColorTable(CC, target, internalformat, width, format, type, data);
 }
 
-MGLAPI void glColorTableEXT(GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, GLvoid *data)
+MGLAPI void glColorTableEXT(GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, const GLvoid *data)
 {
 	GLColorTable(CC, target, internalformat, width, format, type, data);
 }
@@ -951,7 +951,7 @@ MGLAPI void glMultiTexCoord2fARB(GLenum 
 #undef thisvertex
 }
 
-MGLAPI void glMultiTexCoord2fvARB(GLenum unit, GLfloat *v)
+MGLAPI void glMultiTexCoord2fvARB(GLenum unit, const GLfloat *v)
 {
 	int u = unit - GL_TEXTURE0_ARB;
 
@@ -979,4 +979,9 @@ MGLAPI void mglDrawMultitexBuffer(GLenum
 	MGLDrawMultitexBuffer (CC, s, d, env);
 }
 
+/* dummies (so that uhexen2 code builds..) */
+MGLAPI void glStencilFunc(GLenum func, GLint ref, GLuint mask) { }
+MGLAPI void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) { }
+MGLAPI void glClearStencil(GLint s) { }
+
 #endif

diff -urNp MiniGL~/src/sysinc.h MiniGL/src/sysinc.h
--- MiniGL~/src/sysinc.h	2002-11-30 08:15:44.000000000 +0200
+++ MiniGL/src/sysinc.h	2016-07-01 07:01:10.000000000 +0300
@@ -104,10 +104,10 @@ extern struct Library *Warp3DBase;
 
 #pragma default-align
 
-    #include "/include/mgl/gl.h"
+    #include "../include/mgl/gl.h"
 
 	#ifndef inline
-	#define inline
+	#define inline inline
 	#endif
 
     #define INLINE inline
diff -urNp MiniGL~/src/aclip.c MiniGL/src/aclip.c
--- MiniGL~/src/aclip.c	2002-11-30 08:15:34.000000000 +0200
+++ MiniGL/src/aclip.c	2016-07-01 07:01:10.000000000 +0300
@@ -12,7 +12,9 @@
  *
  */
 
+#if 0
 static char rcsid[] = "$Id: aclip.c,v 1.1.1.1 2000/04/07 19:44:51 hfrieden Exp $";
+#endif
 
 #include "sysinc.h"
 #include "vertexarray.h"
diff -urNp MiniGL~/src/context.c MiniGL/src/context.c
--- MiniGL~/src/context.c	2002-11-30 08:15:36.000000000 +0200
+++ MiniGL/src/context.c	2016-07-01 07:01:10.000000000 +0300
@@ -19,7 +19,9 @@
 #include <stdlib.h>
 #include <string.h>
 
+#if 0
 static char rcsid[] = "$Id: context.c,v 1.1.1.1 2000/04/07 19:44:51 hfrieden Exp $";
+#endif
 
 
 extern void GLMatrixInit(GLcontext context);
@@ -224,15 +226,15 @@ static GLboolean vid_ReopenDisplay(GLcon
 
 	struct TagItem OpenWinTags[] =
 	{
-		WA_CustomScreen,        0,
-		WA_Width,               0,
-		WA_Height,              0,
-		WA_Left,                0,
-		WA_Top,                 0,
-		WA_Title,               0,
-		WA_Flags,               WFLG_ACTIVATE|WFLG_BORDERLESS|WFLG_BACKDROP|WFLG_REPORTMOUSE|WFLG_RMBTRAP,
-		WA_IDCMP,               0,
-		TAG_DONE,               0
+		{WA_CustomScreen,0},
+		{WA_Width,       0},
+		{WA_Height,      0},
+		{WA_Left,        0},
+		{WA_Top,         0},
+		{WA_Title,       0},
+		{WA_Flags,       WFLG_ACTIVATE|WFLG_BORDERLESS|WFLG_BACKDROP|WFLG_REPORTMOUSE|WFLG_RMBTRAP},
+		{WA_IDCMP,       0},
+		{TAG_DONE,       0}
 	};
 
 	if (!context)
@@ -1159,7 +1161,6 @@ void MGLSwitchDisplay(GLcontext context)
 }
 
 
-
 //Multitexture buffer:
 
 extern void FreeMtex();
@@ -1175,16 +1176,14 @@ GLboolean MGLInitContext(GLcontext conte
 /*
 allocate w array that is large enough to cope with almost any texcoordstride - this array is used for all textured, unclipped primitives that go theough the vetexarray pipeline
 */
- 
-	context->WBuffer	    =
-malloc(64*newVertexBufferSize);
+
+	context->WBuffer	    = malloc(64*newVertexBufferSize);
 	if (!context->WBuffer)
 		return GL_FALSE;
 
 	//this is for glArrayElement and for glDrawElements index-conversion:
 
-	context->ElementIndex	    =
-malloc(sizeof(UWORD)*(newVertexBufferSize));
+	context->ElementIndex	    = malloc(sizeof(UWORD)*(newVertexBufferSize));
 
 	if (!context->ElementIndex)
 		return GL_FALSE;
@@ -1204,14 +1203,12 @@ malloc(sizeof(UWORD)*(newVertexBufferSiz
 	if(!AllocMtex(newMTBufferSize))
 		return GL_FALSE;
 
-
 	context->NormalBufferPointer = 0;
 
 	context->NormalBuffer[0].x = 0.f;
 	context->NormalBuffer[0].y = 0.f;
 	context->NormalBuffer[0].z = 0.f;
 
-
 	context->TexBufferSize      = newTextureBufferSize;
 	context->w3dTexBuffer       = malloc(sizeof(W3D_Texture *) * newTextureBufferSize);
 	context->GeneratedTextures  = malloc(sizeof(GLubyte) * newTextureBufferSize);
@@ -1219,7 +1216,6 @@ malloc(sizeof(UWORD)*(newVertexBufferSiz
 	if (!context->w3dTexBuffer || !context->GeneratedTextures)
 		return GL_FALSE;
 
-
 	context->w3dTexMemory       = malloc(sizeof(GLubyte *) * newTextureBufferSize);
 	if (!context->w3dTexMemory)
 		return GL_FALSE;
@@ -1268,7 +1264,6 @@ malloc(sizeof(UWORD)*(newVertexBufferSiz
 	    context->TexEnv[i]		= GL_MODULATE;
 	}
 
-
 	context->CurTexEnv = 0;
 
 	context->MinFilter = GL_NEAREST;
@@ -1364,17 +1359,16 @@ malloc(sizeof(UWORD)*(newVertexBufferSiz
         context->ArrayPointer.transformed = 0;
         context->ArrayPointer.state = 0; //pipeline state
 
-
-	  // set Vertex Array texture to NULL:
+  // set Vertex Array texture to NULL:
         context->w3dContext->CurrentTex[0] = NULL;
 
-	  // set constant elements of vertexpointers once and for all
+  // set constant elements of vertexpointers once and for all
         context->w3dContext->CPFlags = 0;
         context->w3dContext->VPFlags = 0;
         context->w3dContext->TPFlags[0] = W3D_TEXCOORD_NORMALIZED;
         context->w3dContext->TPVOffs[0] = 4;
 
-//End surgeon	  
+//End surgeon
 
 #if 0
 	context->DrawElementsHook   = 0;
@@ -1491,9 +1485,8 @@ void MGLDeleteContext(GLcontext context)
 	free(context);
 }
 
-#define ED (flag == GL_TRUE?W3D_ENABLE:W3D_DISABLE)
 
-extern void tex_SetEnv(GLcontext context, GLenum env);
+#define ED (flag == GL_TRUE?W3D_ENABLE:W3D_DISABLE)
 
 void MGLSetState(GLcontext context, const GLenum cap, const GLboolean flag)//surgeon: const
 {
@@ -1510,7 +1503,7 @@ void MGLSetState(GLcontext context, cons
 			context->AlphaTest_State = flag;
 			W3D_SetState(context->w3dContext, W3D_ALPHATEST, ED);
 			}
-		break;
+			break;
 		case GL_BLEND:
 			//surgeon: added state-check
 			if(context->Blend_State != flag)
@@ -1518,17 +1511,14 @@ void MGLSetState(GLcontext context, cons
 			context->Blend_State = flag;
 			W3D_SetState(context->w3dContext, W3D_BLENDING, ED);
 			}
-		break;
+			break;
 		case GL_TEXTURE_2D:
-
 			if(active == 0 && context->Texture2D_State[0] != flag)
 			{
 			      W3D_SetState(context->w3dContext, W3D_TEXMAPPING, ED);
 			}
-
 			context->Texture2D_State[active] = flag;
-
-		break;
+			break;
 		case GL_TEXTURE_GEN_S:
 			context->TextureGenS_State = flag;
 			break;
@@ -1543,19 +1533,17 @@ void MGLSetState(GLcontext context, cons
 		case GL_SCISSOR_TEST:
 			context->Scissor_State = flag;
 			if(flag == GL_FALSE) //restore
-			W3D_SetScissor(context->w3dContext, &(context->scissor));
+			  W3D_SetScissor(context->w3dContext, &(context->scissor));
 			break;
 		case GL_CULL_FACE:
 			context->CullFace_State = flag;
-
 			break;
 		case GL_DEPTH_WRITEMASK:
-			context->CurWriteMask = flag ;
-		break ;
+			context->CurWriteMask = flag;
+			break;
 		case GL_DEPTH_TEST:
 			context->CurDepthTest = flag ;
 			context->DepthTest_State = flag;
-
 			W3D_SetState(context->w3dContext, W3D_ZBUFFER, ED);
 			if (flag == GL_TRUE)
 			{
@@ -1566,7 +1554,6 @@ void MGLSetState(GLcontext context, cons
 			{
 				W3D_SetState(context->w3dContext, W3D_ZBUFFERUPDATE, W3D_DISABLE);
 			}
-
 			break;
 		case GL_DITHER:
 			context->Dither_State = flag;
diff -urNp MiniGL~/src/draw.c MiniGL/src/draw.c
--- MiniGL~/src/draw.c	2002-11-30 08:15:40.000000000 +0200
+++ MiniGL/src/draw.c	2016-07-01 07:01:10.000000000 +0300
@@ -31,15 +31,15 @@
 #include <math.h>
 
 #include <stdlib.h>
-#ifdef __VBCC__
 #include <stdio.h>
-#endif
 
 #ifdef DISABLE_TRANSFORMATION
 #warning "Compiling without transformation pipeline. Only flat geometry supported"
 #endif
 
+#if 0
 static char rcsid[] = "$Id: draw.c,v 1.4 2001/02/01 14:36:49 tfrieden Exp $";
+#endif
 
 #define DUMP_VERTEX2(vert)
 
@@ -72,10 +72,10 @@ void d_DrawFlatStrip     (GLcontext);
 #endif
 
 
-INLINE GLvoid v_Transform(GLcontext context);
+static INLINE GLvoid v_Transform(GLcontext context);
 
 #ifndef __VBCC__ //replaced with macro
-	INLINE void v_ToScreen(GLcontext context, int i);
+	static INLINE void v_ToScreen(GLcontext context, int i);
 #endif
 
 extern void m_CombineMatrices(GLcontext context);
@@ -96,7 +96,7 @@ static PolyBuffer clip[MGL_MAXVERTS];
 
 //Surgeon: moved from GLVertex*f to after culling:
 
-INLINE void PrepTexCoords(GLcontext context, int start, const int numverts, GLboolean cullfan)
+static INLINE void PrepTexCoords(GLcontext context, int start, const int numverts, GLboolean cullfan)
 {
    int i;
    GLfloat umul, vmul;
@@ -158,7 +158,7 @@ INLINE void PrepTexCoords(GLcontext cont
 */
 
 
-void v_GenTexCoords(GLcontext context, int vertex)
+static void v_GenTexCoords(GLcontext context, int vertex)
 {
 #ifdef __M68K__
 	float u[4];
@@ -450,7 +450,7 @@ void v_GenTexCoords(GLcontext context, i
 }
 
 
-INLINE GLvoid v_Transform(GLcontext context)
+static INLINE GLvoid v_Transform(GLcontext context)
 {
 #if !defined(DISABLE_TRANSFORMATION)
 	int i;
@@ -574,7 +574,7 @@ ctx->VertexBuffer[vnum].v.x = ctx->ax + 
 ctx->VertexBuffer[vnum].v.y = ctx->ay - ctx->VertexBuffer[vnum].by * wdiv * ctx->sy; \
 ctx->VertexBuffer[vnum].v.z = ctx->az + ctx->VertexBuffer[vnum].bz * wdiv * ctx->sz; \
 if (ctx->ZOffset_State == GL_TRUE) ctx->VertexBuffer[vnum].v.z += (W3D_Float)ctx->ZOffset; \
-if (context->CurrentTexQValid == GL_FALSE) ctx->VertexBuffer[vnum].v.w = wdiv; \
+if (ctx->CurrentTexQValid == GL_FALSE) ctx->VertexBuffer[vnum].v.w = wdiv; \
 else ctx->VertexBuffer[vnum].v.w = ctx->VertexBuffer[vnum].q;}\
 
 #define v_ToScreenVA(ctx,vnum){\
@@ -584,12 +584,12 @@ ctx->VertexBuffer[vnum].bx = ctx->ax + c
 ctx->VertexBuffer[vnum].by = ctx->ay - ctx->VertexBuffer[vnum].by * wdiv * ctx->sy; \
 ctx->VertexBuffer[vnum].bz = ctx->az + ctx->VertexBuffer[vnum].bz * wdiv * ctx->sz; \
 if (ctx->ZOffset_State == GL_TRUE) ctx->VertexBuffer[vnum].bz += (W3D_Float)ctx->ZOffset; \
-if (context->CurrentTexQValid == GL_FALSE) ctx->VertexBuffer[vnum].v.w = wdiv; \
+if (ctx->CurrentTexQValid == GL_FALSE) ctx->VertexBuffer[vnum].v.w = wdiv; \
 else ctx->VertexBuffer[vnum].v.w = ctx->VertexBuffer[vnum].q;}\
 
 #else
 
-INLINE void v_ToScreen(GLcontext context, int i)
+static INLINE void v_ToScreen(GLcontext context, int i)
 {
 #if !defined(DISABLE_TRANSFORMATION)
 
@@ -616,7 +616,7 @@ INLINE void v_ToScreen(GLcontext context
 #endif
 }
 
-INLINE void v_ToScreenVA(GLcontext context, int i)
+static INLINE void v_ToScreenVA(GLcontext context, int i)
 {
 	float w;
 	w = 1.0 / context->VertexBuffer[i].bw;
@@ -1358,7 +1358,7 @@ void d_DrawTriangleFan(GLcontext context
    fan.tex = context->w3dTexBuffer[context->CurrentBinding];
    fan.st_pattern = NULL;
 
-     j = 0, first = 0;
+     j = 0; first = 0;
      do
      {
 	  PolyBuffer *p = &clip[j];
diff -urNp MiniGL~/src/fog.c MiniGL/src/fog.c
--- MiniGL~/src/fog.c	2002-11-30 08:15:40.000000000 +0200
+++ MiniGL/src/fog.c	2016-07-01 07:01:10.000000000 +0300
@@ -14,7 +14,9 @@
 
 #include "sysinc.h"
 
+#if 0
 static char rcsid[] = "$Id: fog.c,v 1.1.1.1 2000/04/07 19:44:51 hfrieden Exp $";
+#endif
 
 void GLFogf(GLcontext context, GLenum pname, GLfloat param)
 {
@@ -64,7 +66,7 @@ void GLFogf(GLcontext context, GLenum pn
 
 
 
-void GLFogfv(GLcontext context, GLenum pname, GLfloat *param)
+void GLFogfv(GLcontext context, GLenum pname, const GLfloat *param)
 {
 	context->FogDirty = GL_TRUE;
 
diff -urNp MiniGL~/src/glu.c MiniGL/src/glu.c
--- MiniGL~/src/glu.c	2002-11-30 08:15:40.000000000 +0200
+++ MiniGL/src/glu.c	2016-07-01 07:01:10.000000000 +0300
@@ -46,7 +46,9 @@
 #define VEC_PRINT(v)                                     \
     printf("<%f, %f, %f>\n", v[0], v[1], v[2]);
 
+#if 0
 static char rcsid[] = "$Id: glu.c,v 1.1.1.1 2000/04/07 19:44:51 tfrieden Exp $ ";
+#endif
 
 
 void GLULookAt(GLfloat ex, GLfloat ey, GLfloat ez, GLfloat cx, GLfloat cy, GLfloat cz, GLfloat ux, GLfloat uy, GLfloat uz)
diff -urNp MiniGL~/src/hclip.c MiniGL/src/hclip.c
--- MiniGL~/src/hclip.c	2002-11-30 08:15:42.000000000 +0200
+++ MiniGL/src/hclip.c	2016-07-01 07:01:10.000000000 +0300
@@ -12,7 +12,9 @@
  *
  */
 
+#if 0
 static char rcsid[] = "$Id: hclip.c,v 1.1.1.1 2000/04/07 19:44:51 hfrieden Exp $";
+#endif
 
 #include "sysinc.h"
 #include <math.h>
diff -urNp MiniGL~/src/init.c MiniGL/src/init.c
--- MiniGL~/src/init.c	2002-11-30 08:15:42.000000000 +0200
+++ MiniGL/src/init.c	2016-08-08 05:55:00.000000000 +0300
@@ -16,17 +16,15 @@
 #include <stdio.h>
 
 
+#if 0
 static char rcsid[] UNUSED = "$Id: init.c,v 1.4 2001/12/25 00:55:26 tfrieden Exp $";
+#endif
 
 //surgeon: added 11-04-02 - initializes glDrawArrays to glDrawElements wrapper for clipping with compiled arrays
 
 extern void Init_ArrayToElements_Warpper(void);
 
 
-struct Library *UtilityBase;
-struct IntuitionBase *IntuitionBase;
-struct GfxBase *GfxBase;
-
 #ifndef __PPC__
 	extern struct DosLibrary *DOSBase;
 	extern struct ExecBase *SysBase;
@@ -44,9 +42,6 @@ struct Library *CyberGfxBase = NULL;
 
 GLboolean MGLInit(void)
 {
-	IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", 0L);
-	GfxBase = (struct GfxBase *)OpenLibrary("graphics.library", 0L);
-	UtilityBase = OpenLibrary("utility.library", 0L);
 #ifdef __PPC__
 	Warp3DPPCBase = OpenLibrary("Warp3DPPC.library", 2L);
 #else
@@ -54,7 +49,7 @@ GLboolean MGLInit(void)
 #endif
 	CyberGfxBase = OpenLibrary("cybergraphics.library", 0L);
 
-	if (!IntuitionBase || !GfxBase || !UtilityBase || !CyberGfxBase ||
+	if (!CyberGfxBase ||
 #ifdef __PPC__
 	    !Warp3DPPCBase)
 #else
@@ -62,16 +57,12 @@ GLboolean MGLInit(void)
 #endif
 	{
 	    printf("Library initialization failed:\n");
-
-	    if (!IntuitionBase) printf("- intuition.library (How are you doing this ?)\n");
-	    if (!GfxBase)       printf("- graphics.library (Strange!)\n");
 #ifdef __PPC__
 	    if (!Warp3DPPCBase) printf("- Warp3DPPC.library\n");
 #else
 	    if (!Warp3DBase)    printf("- Warp3D.library\n");
 #endif
 	    if (!CyberGfxBase)  printf("- cybergraphics.library\n");
-	    
 	    MGLTerm();
 	    return GL_FALSE;
 	}
@@ -100,13 +91,4 @@ void MGLTerm(void)
 	if (Warp3DBase)         CloseLibrary(Warp3DBase);
 	Warp3DBase = NULL;
 	#endif
-
-	if (IntuitionBase)      CloseLibrary((struct Library *)IntuitionBase);
-	IntuitionBase = NULL;
-
-	if (GfxBase)            CloseLibrary((struct Library *)GfxBase);
-	GfxBase = NULL;
-
-	if (UtilityBase)        CloseLibrary(UtilityBase);
-	UtilityBase = NULL;
 }
diff -urNp MiniGL~/src/matrix.c MiniGL/src/matrix.c
--- MiniGL~/src/matrix.c	2002-11-30 08:15:42.000000000 +0200
+++ MiniGL/src/matrix.c	2016-11-01 11:01:00.000000000 +0300
@@ -33,41 +33,43 @@
 #warning "Compiling without transformation pipeline. Only flat geometry supported"
 #endif
 
+#if 0
 static char rcsid[] = "$Id: draw.c,v 1.4 2001/02/01 14:36:49 tfrieden Exp $";
+#endif
 
 typedef void (*Multfn)(struct Matrix_t *, float *, struct Matrix_t *);
 
-INLINE void m_MatCopy(Matrix *pA, Matrix *pB);
-INLINE void m_MatMultGeneral(Matrix *pA, float *pB, Matrix *pC);
+static INLINE void m_MatCopy(Matrix *pA, Matrix *pB);
+static INLINE void m_MatMultGeneral(Matrix *pA, float *pB, Matrix *pC);
 
-INLINE void m_MatMultAIdent(float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultAPerspB0001(Matrix *pA, float *pB, Matrix *pC); //surgeon: common case for m_CombineMatrices
-INLINE void m_MatMultRotRot(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultBRot001(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultBRot010(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultBRot100(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_BRot001(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_BRot010(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_BRot100(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_B0001(Matrix *pA, float *pB, Matrix *pC); //surgeon
-
-INLINE void m_MatMultB0001(Matrix *pA, float *pB, Matrix *pC);
-INLINE void m_MatMultA0001(Matrix *pA, float *pB, Matrix *pC);
-INLINE void m_MatMultATrans(Matrix *pA, float *pB, Matrix *pC);
-INLINE void m_MatMultBTrans(Matrix *pA, float *pB, Matrix *pC);
-INLINE void m_MatMultBScale(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultBOrtho(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultBPersp(Matrix *pA, float *pB, Matrix *pC); //surgeon
-
-INLINE void m_MatMultA0001_BTrans(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_BScale(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_BOrtho(Matrix *pA, float *pB, Matrix *pC); //surgeon
-INLINE void m_MatMultA0001_BPersp(Matrix *pA, float *pB, Matrix *pC); //surgeon
-
-INLINE void m_LoadMatrixf(Matrix *pA, const float *v);
-INLINE void m_LoadMatrixd(Matrix *pA, const double *v);
-INLINE void m_LoadIdentity(Matrix *pA);
-INLINE void m_Mult(Matrix *pA, float *v, int vtype, Matrix *pC);
+static INLINE void m_MatMultAIdent(float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultAPerspB0001(Matrix *pA, float *pB, Matrix *pC); //surgeon: common case for m_CombineMatrices
+static INLINE void m_MatMultRotRot(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultBRot001(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultBRot010(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultBRot100(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_BRot001(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_BRot010(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_BRot100(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_B0001(Matrix *pA, float *pB, Matrix *pC); //surgeon
+
+static INLINE void m_MatMultB0001(Matrix *pA, float *pB, Matrix *pC);
+static INLINE void m_MatMultA0001(Matrix *pA, float *pB, Matrix *pC);
+static INLINE void m_MatMultATrans(Matrix *pA, float *pB, Matrix *pC);
+static INLINE void m_MatMultBTrans(Matrix *pA, float *pB, Matrix *pC);
+static INLINE void m_MatMultBScale(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultBOrtho(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultBPersp(Matrix *pA, float *pB, Matrix *pC); //surgeon
+
+static INLINE void m_MatMultA0001_BTrans(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_BScale(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_BOrtho(Matrix *pA, float *pB, Matrix *pC); //surgeon
+static INLINE void m_MatMultA0001_BPersp(Matrix *pA, float *pB, Matrix *pC); //surgeon
+
+static INLINE void m_LoadMatrixf(Matrix *pA, const float *v);
+static INLINE void m_LoadMatrixd(Matrix *pA, const double *v);
+static INLINE void m_LoadIdentity(Matrix *pA);
+static INLINE void m_Mult(Matrix *pA, float *v, int vtype, Matrix *pC);
 void m_CombineMatrices(GLcontext context);
 void GLMatrixInit(GLcontext context);
 
@@ -87,7 +89,8 @@ void GLMatrixInit(GLcontext context);
 ** Computes the determinant of the upper 3x3 submatrix block
 ** of the supplied matrix
 */
-INLINE GLfloat m_Determinant(Matrix *pA)
+#if 0 /* not used */
+static INLINE GLfloat m_Determinant(Matrix *pA)
 {
    #define a(x) (pA->v[CM_##x])
    float a0 = a(0);
@@ -100,20 +103,19 @@ INLINE GLfloat m_Determinant(Matrix *pA)
    float a7 = a(7);
    float a8 = a(8);
 
-
     return ( a0*a4*a8  +  a1*a5*a6  + a2*a3*a7 -  a0*a5*a7  -  a1*a3*a8  - a2*a4*a6);
 
    #undef a
 }
+#endif /* #if 0 */
 
 /*
 ** Builds the inverse of the upper 3x3 submatrix block of the
 ** supplied matrix for the backtransformation of the normals
 */
 
-void m_DoInvert(Matrix *pA, int flags, GLfloat *out)
+static INLINE void m_DoInvert(Matrix *pA, int flags, GLfloat *out)
 {
-
    #define a(x) (pA->v[CM_##x])
 
    float a0 = a(0);
@@ -146,7 +148,7 @@ void m_DoInvert(Matrix *pA, int flags, G
    #undef a
 }
 
-void m_PrintMatrix(Matrix *pA);
+static void m_PrintMatrix(Matrix *pA);
 
 void m_BuildInverted(GLcontext context)
 {
@@ -162,14 +164,13 @@ void m_BuildInverted(GLcontext context)
 ** Copy matrix B to matrix A
 ** A = B
 */
-INLINE void m_MatCopy(Matrix *pA, Matrix *pB)
+static INLINE void m_MatCopy(Matrix *pA, Matrix *pB)
 {
    int i;
 
 //   for (i=0; i<16; i++)
    i = 0;
    do{
- 
 	pA->v[i] = pB->v[i];
 	i++;
 	} while (i<16);
@@ -182,7 +183,7 @@ INLINE void m_MatCopy(Matrix *pA, Matrix
 ** General case: Matrix multiply
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultGeneral(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultGeneral(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -299,15 +300,15 @@ float a44 = a(44);
 
    #undef a
    #undef b
+   #undef c
 }
 
 
-
 /*
 ** Matrix A is an identity matrix
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultAIdent(float *pB, Matrix *pC)
+static INLINE void m_MatMultAIdent(float *pB, Matrix *pC)
 {
    int i;
 
@@ -323,7 +324,7 @@ INLINE void m_MatMultAIdent(float *pB, M
 ** Matrix A and matrix B are rotation matrices
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultRotRot(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultRotRot(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -362,6 +363,7 @@ INLINE void m_MatMultRotRot(Matrix *pA, 
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
@@ -369,7 +371,7 @@ INLINE void m_MatMultRotRot(Matrix *pA, 
 ** Matrix B has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultAPerspB0001(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultAPerspB0001(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -410,13 +412,14 @@ INLINE void m_MatMultAPerspB0001(Matrix 
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
 ** Matrix B has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultB0001(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultB0001(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -478,6 +481,7 @@ c(44) = a44; 
 
    #undef a
    #undef b
+   #undef c
 }
 
 // --> surgeon begin
@@ -487,7 +491,7 @@ c(44) = a44; 
 ** Matrix A has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_B0001(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_B0001(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -541,6 +545,7 @@ c(34) = a34; 
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
@@ -548,7 +553,7 @@ c(34) = a34; 
 ** Matrix A has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_BRot001(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BRot001(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -589,6 +594,7 @@ INLINE void m_MatMultA0001_BRot001(Matri
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
@@ -596,7 +602,7 @@ INLINE void m_MatMultA0001_BRot001(Matri
 ** Matrix A has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_BRot010(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BRot010(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -637,6 +643,7 @@ INLINE void m_MatMultA0001_BRot010(Matri
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
@@ -644,7 +651,7 @@ INLINE void m_MatMultA0001_BRot010(Matri
 ** Matrix A has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_BRot100(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BRot100(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -686,13 +693,14 @@ INLINE void m_MatMultA0001_BRot100(Matri
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
 ** Matrix B has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultBRot001(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBRot001(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -737,13 +745,14 @@ INLINE void m_MatMultBRot001(Matrix *pA,
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
 ** Matrix B has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultBRot010(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBRot010(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -788,13 +797,14 @@ INLINE void m_MatMultBRot010(Matrix *pA,
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
 ** Matrix B has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultBRot100(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBRot100(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -840,6 +850,7 @@ INLINE void m_MatMultBRot100(Matrix *pA,
 
    #undef a
    #undef b
+   #undef c
 }
 // <--surgeon end
 
@@ -847,7 +858,7 @@ INLINE void m_MatMultBRot100(Matrix *pA,
 ** Matrix A has three rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -893,13 +904,14 @@ INLINE void m_MatMultA0001(Matrix *pA, f
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
 ** Matrix A is a translation matrix
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultATrans(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultATrans(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -958,17 +970,16 @@ b34 += b44*a34;
    c(44) = b44;
    c(43) = b43;
 
-
-
    #undef a
    #undef b
+   #undef c
 }
 
 /*
 ** Matrix B is a translation matrix
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultBTrans(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBTrans(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1030,6 +1041,7 @@ c(44) = a44; 
 
    #undef a
    #undef b
+   #undef c
 }
 
 //surgeon: added scaling, ortho and perspective matrices
@@ -1037,7 +1049,7 @@ c(44) = a44; 
 ** Matrix B is a scaling matrix
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultBScale(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBScale(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1084,12 +1096,14 @@ INLINE void m_MatMultBScale(Matrix *pA, 
 
    #undef a
    #undef b
+   #undef c
 }
+
 /*
 ** Matrix B is a orthogonal matrix
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultBOrtho(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBOrtho(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1151,9 +1165,10 @@ c(44) = a44; 
 
    #undef a
    #undef b
+   #undef c
 }
 
-INLINE void m_MatMultBPersp(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultBPersp(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1212,9 +1227,9 @@ c(23) = a24; 
 c(33) = a34; 
 c(43) = a44; 
 
-
    #undef a
    #undef b
+   #undef c
 }
 
 //surgeon begin -->
@@ -1223,7 +1238,7 @@ c(43) = a44; 
 ** Matrix A has 3 rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_BTrans(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BTrans(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1243,7 +1258,6 @@ INLINE void m_MatMultA0001_BTrans(Matrix
    float a34 = a(34),  b34 = b(34);
 
 
-
 a14 += b34*a13;
 a24 += b34*a23;
 a34 += b34*a33;
@@ -1279,6 +1293,7 @@ c(44) = 1.f; 
 
    #undef a
    #undef b
+   #undef c
 }
 
 //surgeon: added scaling, ortho and perspective matrices
@@ -1287,7 +1302,7 @@ c(44) = 1.f; 
 ** Matrix A has 3 rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_BScale(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BScale(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1329,6 +1344,7 @@ INLINE void m_MatMultA0001_BScale(Matrix
 
    #undef a
    #undef b
+   #undef c
 }
 
 /*
@@ -1336,7 +1352,7 @@ INLINE void m_MatMultA0001_BScale(Matrix
 ** Matrix A has 3 rows
 ** Multiply matrix A by float field, storing the result in matrix C
 */
-INLINE void m_MatMultA0001_BOrtho(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BOrtho(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1390,9 +1406,10 @@ c(44) = 1.f; 
 
    #undef a
    #undef b
+   #undef c
 }
 
-INLINE void m_MatMultA0001_BPersp(Matrix *pA, float *pB, Matrix *pC)
+static INLINE void m_MatMultA0001_BPersp(Matrix *pA, float *pB, Matrix *pC)
 {
    #define a(x) (pA->v[OF_##x])
    #define b(x) (pB[OF_##x])
@@ -1410,10 +1427,12 @@ INLINE void m_MatMultA0001_BPersp(Matrix
    float a32 = a(32);
    float a33 = a(33),  b33 = b(33);
    float a34 = -a(34),  b34 = b(34);
+   /*
    float a41 = a(41);
    float a42 = a(42);
    float a43 = a(43);
    float a44 = -a(44);
+   */
 
    c(11) = b11*a11;
    c(21) = b11*a21;
@@ -1447,14 +1466,14 @@ c(23) = a24; 
 c(33) = a34; 
 c(43) = -1; 
 
-
    #undef a
    #undef b
+   #undef c
 }
 
 //surgeon end <--
 
-INLINE void m_LoadMatrixf(Matrix *pA, const float *v)
+static INLINE void m_LoadMatrixf(Matrix *pA, const float *v)
 {
    #define a(x) (pA->v[OF_##x] = *v++)
 
@@ -1470,7 +1489,7 @@ INLINE void m_LoadMatrixf(Matrix *pA, co
    #undef a
 }
 
-INLINE void m_LoadMatrixd(Matrix *pA, const double *v)
+static INLINE void m_LoadMatrixd(Matrix *pA, const double *v)
 {
    #define a(x) (pA->v[OF_##x] = (float)*v++)
 
@@ -1488,7 +1507,7 @@ INLINE void m_LoadMatrixd(Matrix *pA, co
 }
 
 
-INLINE void m_LoadIdentity(Matrix *pA)
+static INLINE void m_LoadIdentity(Matrix *pA)
 {
    #define a(x) (pA->v[OF_##x] = 0.f)
    #define b(x) (pA->v[OF_##x] = 1.f)
@@ -1510,7 +1529,7 @@ INLINE void m_LoadIdentity(Matrix *pA)
 ** this routine may select an optimized matrix multiplication routine.
 */
 
-INLINE void m_Mult(Matrix *pA, float *v, int vtype, Matrix *pC)
+static INLINE void m_Mult(Matrix *pA, float *v, int vtype, Matrix *pC)
 {
 
 	if(pA->flags == MGLMAT_IDENTITY)
@@ -1654,7 +1673,7 @@ void m_CombineMatrices(GLcontext context
 }
 
 
-void m_PrintMatrix(Matrix *pA)
+static void m_PrintMatrix(Matrix *pA)
 {
 #ifndef NDEBUG
    #define a(x) (pA->v[OF_##x])
diff -urNp MiniGL~/src/others.c MiniGL/src/others.c
--- MiniGL~/src/others.c	2002-11-30 08:15:44.000000000 +0200
+++ MiniGL/src/others.c	2016-07-01 07:01:10.000000000 +0300
@@ -17,7 +17,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+#if 0
 static char rcsid[] = "$Id: others.c,v 1.1.1.1 2000/04/07 19:44:51 hfrieden Exp $";
+#endif
 
 
 #ifndef __PPC__
@@ -141,6 +143,8 @@ void GLBlendFunc(GLcontext context, GLen
 		BLD(ONE_MINUS_SRC_ALPHA);
 		BLD(DST_ALPHA);
 		BLD(ONE_MINUS_DST_ALPHA);
+
+	default: return;
 	}
 
 	// Try to set the mode, if unavailable, switch to
@@ -264,6 +268,9 @@ void  GLGetIntegerv(GLcontext context, G
 	case GL_MAX_TEXTURE_UNITS_ARB:
 		*params = MAX_TEXUNIT;
 	   return ;
+	case GL_STENCIL_BITS:
+		*params = 0;/* */
+	   return ;
       default:
       	*params = 0 ;
          GLFlagError(context, 1, GL_INVALID_ENUM);
@@ -360,6 +367,9 @@ GLboolean GLIsEnabled(GLcontext context,
    	case GL_BLEND:
          return( context->Blend_State ) ;
 
+      case GL_ALPHA_TEST:
+         return( context->AlphaTest_State ) ;
+
       case GL_DEPTH_TEST:
          return( context->DepthTest_State ) ;
 
@@ -367,11 +377,10 @@ GLboolean GLIsEnabled(GLcontext context,
 	   	return (context->Texture2D_State[context->ActiveTexture]) ;
 
 	default:
-	#ifndef __VBCC__
-		GLFlagError(context, 1, GL_INVALID_ENUM);
-	#else
-		return GL_FALSE;
+	#ifndef GL_NOERRORCHECK
+		context->CurrentError = GL_INVALID_ENUM;
 	#endif
+		return GL_FALSE;
 	}
 }
 
@@ -381,7 +390,7 @@ void MGLSetZOffset(GLcontext context, GL
 	context->ZOffset = offset;
 }
 
-void MGLWriteShotPPM(GLcontext context, char *filename)
+void MGLWriteShotPPM(GLcontext context, const char *filename)
 {
 	GLubyte *pixelline;
 	FILE *f;
@@ -481,7 +490,7 @@ void MGLMainLoop(GLcontext context)
 
 	while (context->Running == GL_TRUE)
 	{
-		while (imsg = (struct IntuiMessage *)GetMsg(window->UserPort))
+		while ((imsg = (struct IntuiMessage *)GetMsg(window->UserPort)) != NULL)
 		{
 			Class  = imsg->Class;
 			Code   = imsg->Code;
diff -urNp MiniGL~/src/texture.c MiniGL/src/texture.c
--- MiniGL~/src/texture.c	2002-11-30 08:15:44.000000000 +0200
+++ MiniGL/src/texture.c	2016-07-01 07:01:10.000000000 +0300
@@ -20,8 +20,9 @@
 #include <string.h> //inlined memcpy
 #endif
 
-
+#if 0
 static char rcsid[] = "$Id: texture.c,v 1.1.1.1 2000/04/07 19:44:51 tfrieden Exp $";
+#endif
 
 
 #ifndef __PPC__
@@ -29,10 +30,10 @@ extern struct ExecBase *SysBase;
 #endif
 
 void tex_FreeTextures(GLcontext context);
-void tex_SetEnv(GLcontext context, GLenum env);
-ULONG tex_GLFilter2W3D(GLenum filter);
-void tex_SetFilter(GLcontext context, GLenum min, GLenum mag);
-void tex_SetWrap(GLcontext context, GLenum wrap_s, GLenum wrap_t);
+static void tex_SetEnv(GLcontext context, GLenum env);
+static ULONG tex_GLFilter2W3D(GLenum filter);
+static void tex_SetFilter(GLcontext context, GLenum min, GLenum mag);
+static void tex_SetWrap(GLcontext context, GLenum wrap_s, GLenum wrap_t);
 
 /*
 ** Surgeon: support for GL_ALPHA, GL_LUMINANCE and GL_LUMINANCE_ALPHA
@@ -44,49 +45,45 @@ void tex_SetWrap(GLcontext context, GLen
 
 //Formats directly supported by Warp3D:
 
-void SHORT4444_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void SHORT4444_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void SHORT565_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void SHORT565_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
 
 //supported, but not in hardware on voodoo3:
 
-void L8A8_L8A8(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void L8A8_L8A8(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
 #ifdef EIGHTBIT_TEXTURES
-
-void EIGHT_EIGHT(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
-
+static void EIGHT_EIGHT(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 #endif
 
-
-
 //conversion routines:
 
-void SHORT565_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void SHORT565_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void SHORT4444_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void SHORT4444_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void A8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void A8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void L8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void L8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void RGBA_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void RGBA_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void RGBA_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void RGBA_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void RGB_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void RGB_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void RGB_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void RGB_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-void RGBA4_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
+static void RGBA4_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height);
 
-ULONG MGLConvert(GLcontext context, const GLvoid *inputp, UWORD *output, int width, int height, GLenum internalformat, GLenum format);
+static ULONG MGLConvert(GLcontext context, const GLvoid *inputp, UWORD *output, int width, int height, GLenum internalformat, GLenum format);
 
 static ULONG Allocated_Size = 0;
 static ULONG Peak_Size      = 0;
 
-void *tex_Alloc(ULONG size)
+static void *tex_Alloc(ULONG size)
 {
 	ULONG *x;
 	Allocated_Size += size+4;
@@ -98,7 +95,7 @@ void *tex_Alloc(ULONG size)
 	return x+1;
 }
 
-void tex_Free(void *chunk)
+static void tex_Free(void *chunk)
 {
 	ULONG *mem = (ULONG *)chunk;
 	mem--;
@@ -107,12 +104,14 @@ void tex_Free(void *chunk)
 	free(mem);
 }
 
+#if 0
 void tex_Statistic(void)
 {
 //	printf("Peak Allocation Size: %ld\n", Peak_Size);
 	printf("Peak Allocation Size: %lu\n", Peak_Size); //OF
 
 }
+#endif
 
 void MGLTexMemStat(GLcontext context, GLint *Current, GLint *Peak)
 {
@@ -195,7 +194,7 @@ void tex_FreeTextures(GLcontext context)
 }
 
 
-void tex_SetEnv(GLcontext context, GLenum env)
+static void tex_SetEnv(GLcontext context, GLenum env)
 {
 	W3D_Texture *tex;
 
@@ -223,7 +222,7 @@ void tex_SetEnv(GLcontext context, GLenu
 	}
 }
 
-ULONG tex_GLFilter2W3D(GLenum filter)
+static ULONG tex_GLFilter2W3D(GLenum filter)
 {
 	switch(filter)
 	{
@@ -237,7 +236,7 @@ ULONG tex_GLFilter2W3D(GLenum filter)
 	return 0;
 }
 
-void tex_SetFilter(GLcontext context, GLenum min, GLenum mag)
+static void tex_SetFilter(GLcontext context, GLenum min, GLenum mag)
 {
 	ULONG minf, magf;
 	W3D_Texture *tex;
@@ -255,7 +254,7 @@ void tex_SetFilter(GLcontext context, GL
 	W3D_SetFilter(context->w3dContext, tex, minf, magf);
 }
 
-void tex_SetWrap(GLcontext context, GLenum wrap_s, GLenum wrap_t)
+static void tex_SetWrap(GLcontext context, GLenum wrap_s, GLenum wrap_t)
 {
 	ULONG Ws,Wt;
 	W3D_Texture *tex;
@@ -430,7 +429,7 @@ void GLBindTexture(GLcontext context, GL
 	    realWidth = context->CurUnpackRowLength*x;
 
 
-#define SETUP_LOOP_SHORT(x)                         \
+#define SETUP_LOOP_SHORT                         \
 	UWORD *oldInput;                            \
 	int realWidth = width;                      \
 	if (context->CurUnpackRowLength > 0)        \
@@ -507,7 +506,7 @@ void GLBindTexture(GLcontext context, GL
 ** is not
 */
 
-void tex_AddAlpha(UWORD *output, int width, int height)
+static void tex_AddAlpha(UWORD *output, int width, int height)
 {
 	int size;
 	UBYTE r,g,b,a;
@@ -593,7 +592,7 @@ void tex_ConvertTexture(GLcontext contex
 
 //These formats need no conversion:
 
-void EIGHT_EIGHT (GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void EIGHT_EIGHT (GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE *in = (UBYTE*)input;
@@ -609,7 +608,7 @@ void EIGHT_EIGHT (GLcontext context, GLu
 	}
 }
 
-void L8A8_L8A8(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void L8A8_L8A8(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 
@@ -628,7 +627,7 @@ void L8A8_L8A8(GLcontext context, GLubyt
 	}
 }
 
-void SHORT565_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void SHORT565_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 
@@ -647,7 +646,7 @@ void SHORT565_565(GLcontext context, GLu
 	}
 }
 
-void SHORT4444_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void SHORT4444_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 
@@ -670,7 +669,7 @@ void SHORT4444_4444(GLcontext context, G
 
 #if 1
 
-void A8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void A8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	GLubyte a;
@@ -686,7 +685,7 @@ void A8_ARGB(GLcontext context, GLubyte 
 	}
 }
 
-void L8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void L8_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	GLubyte la,lb,lc;
@@ -704,7 +703,7 @@ void L8_ARGB(GLcontext context, GLubyte 
 
 #endif
 
-void RGBA_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void RGBA_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b,a;
@@ -724,7 +723,7 @@ void RGBA_RGB(GLcontext context, GLubyte
 }
 
 
-void RGBA_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void RGBA_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b,a;
@@ -743,7 +742,7 @@ void RGBA_ARGB(GLcontext context, GLubyt
 	}
 }
 
-void RGB_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void RGB_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b;
@@ -761,7 +760,7 @@ void RGB_RGB(GLcontext context, GLubyte 
 	}
 }
 
-void RGB_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void RGB_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b;
@@ -779,7 +778,7 @@ void RGB_ARGB(GLcontext context, GLubyte
 	}
 }
 
-void SHORT4444_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void SHORT4444_565(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b;
@@ -799,7 +798,7 @@ void SHORT4444_565(GLcontext context, GL
 	}
 }
 
-void SHORT565_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void SHORT565_4444(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b;
@@ -820,7 +819,7 @@ void SHORT565_4444(GLcontext context, GL
 	}
 }
 
-void RGBA4_ARGB (GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void RGBA4_ARGB (GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE r,g,b,a;
@@ -842,7 +841,7 @@ void RGBA4_ARGB (GLcontext context, GLub
 	}
 }
 
-void INDEX_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void INDEX_RGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE ind;
@@ -881,7 +880,7 @@ void INDEX_RGB(GLcontext context, GLubyt
 	}
 }
 
-void INDEX_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
+static void INDEX_ARGB(GLcontext context, GLubyte *input, UWORD *output, int width, int height)
 {
 	int i,j;
 	UBYTE ind;
@@ -923,14 +922,16 @@ void INDEX_ARGB(GLcontext context, GLuby
 
 
 
-ULONG MGLConvert(GLcontext context, const GLvoid *inputp, UWORD *output, int width, int height, GLenum internalformat, GLenum format)
+static ULONG MGLConvert(GLcontext context, const GLvoid *inputp, UWORD *output, int width, int height, GLenum internalformat, GLenum format)
 {
 	GLvoid *input = (GLvoid *)inputp;
 
+	#if 0 /* our callers do this aldeady */
 	if(internalformat == GL_RGB5_A1)
 	{
 		internalformat = GL_RGBA;
 	}
+	#endif
 
 	switch(internalformat) // The format the texture should have
 	{
@@ -1035,9 +1036,10 @@ ULONG MGLConvert(GLcontext context, cons
 			}
 			break;
 	}
+	return 0; /* ERROR !!! */
 }
 
-void GLTexImage2DNoMIP(GLcontext context, GLenum gltarget, GLint level,
+static void GLTexImage2DNoMIP(GLcontext context, GLenum gltarget, GLint level,
 	GLint internalformat, GLsizei width, GLsizei height, GLint border,
 	GLenum format, GLenum type, const GLvoid *pixels);
 
@@ -1159,6 +1161,7 @@ void GLTexImage2D(GLcontext context, GLe
 	*/
 
 	useFormat = MGLConvert(context, pixels, (UWORD *)target, width, height, internalformat, format);
+	if (!useFormat) return; /* ERROR */
 
 	/*
 	** Create a new W3D_Texture if none was present, using the converted
@@ -1226,7 +1229,7 @@ void GLTexImage2D(GLcontext context, GLe
 #endif
 }
 
-void GLTexImage2DNoMIP(GLcontext context, GLenum gltarget, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
+static void GLTexImage2DNoMIP(GLcontext context, GLenum gltarget, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
 {
 	int current;
 	ULONG w,h;
@@ -1294,6 +1297,7 @@ void GLTexImage2DNoMIP(GLcontext context
 	** Convert the data to the target address
 	*/
 	useFormat = MGLConvert(context, pixels, (UWORD *)target, width, height, internalformat, format);
+	if (!useFormat) return; /* ERROR */
 
 	/*
 	** Create a new W3D_Texture if none was present, using the converted
@@ -1355,7 +1359,7 @@ void GLTexImage2DNoMIP(GLcontext context
 
 #ifdef EIGHTBIT_TEXTURES
 
-inline void tex_UpdateScanlineByte(UBYTE *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineByte(UBYTE *start, UBYTE *pixels, int numpixels)
 {
 	int i;
 
@@ -1372,7 +1376,7 @@ inline void tex_UpdateScanlineByte(UBYTE
 }
 #endif
 
-inline void tex_UpdateScanlineShort(UWORD *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineShort(UWORD *start, UBYTE *pixels, int numpixels)
 {
 	int i;
 
@@ -1387,7 +1391,7 @@ inline void tex_UpdateScanlineShort(UWOR
 
 //Conversion:
 
-inline void tex_UpdateScanlineA8_ARGB(UWORD *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineA8_ARGB(UWORD *start, UBYTE *pixels, int numpixels)
 {
 	int i;
 	UBYTE a;
@@ -1399,7 +1403,7 @@ inline void tex_UpdateScanlineA8_ARGB(UW
 	}
 }
 
-inline void tex_UpdateScanlineL8_ARGB(UWORD *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineL8_ARGB(UWORD *start, UBYTE *pixels, int numpixels)
 {
 	int i;
 	UBYTE la,lb,lc;
@@ -1411,7 +1415,7 @@ inline void tex_UpdateScanlineL8_ARGB(UW
 	}
 }
 
-inline void tex_UpdateScanlineAlpha(UWORD *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineAlpha(UWORD *start, UBYTE *pixels, int numpixels)
 {
 	int i;
 	UBYTE r,g,b,a;
@@ -1426,7 +1430,7 @@ inline void tex_UpdateScanlineAlpha(UWOR
 	}
 }
 
-inline void tex_UpdateScanlineNoAlpha(UWORD *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineNoAlpha(UWORD *start, UBYTE *pixels, int numpixels)
 {
 	int i;
 	UBYTE r,g,b;
@@ -1440,13 +1444,13 @@ inline void tex_UpdateScanlineNoAlpha(UW
 	}
 }
 
-inline void tex_UpdateScanlineVerbatim(UBYTE *start, UBYTE *pixels, int numpixels)
+static inline void tex_UpdateScanlineVerbatim(UBYTE *start, UBYTE *pixels, int numpixels)
 {
 	memcpy(pixels, start, numpixels);
 }
 
 
-void GLTexSubImage2DNoMIP(GLcontext context, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+static void GLTexSubImage2DNoMIP(GLcontext context, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
 
 void GLTexSubImage2D(GLcontext context, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
 {
@@ -1470,7 +1474,7 @@ void GLTexSubImage2D(GLcontext context, 
 //    GLFlagError(context, 1, GL_INVALID_OPERATION);
 }
 
-void GLTexSubImage2DNoMIP(GLcontext context, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
+static void GLTexSubImage2DNoMIP(GLcontext context, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
 {
 	UBYTE *where;
 	UBYTE *from = pixels;
@@ -1655,17 +1659,17 @@ void GLTexGeni(GLcontext context, GLenum
 //    GLFlagError(context, 1, GL_INVALID_OPERATION);
 }
 
-void GLColorTable(GLcontext context, GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, GLvoid *data)
+void GLColorTable(GLcontext context, GLenum target, GLenum internalformat, GLint width, GLenum format, GLenum type, const GLvoid *data)
 {
 	int i;
-	GLubyte *palette;
+	const GLubyte *palette;
 	GLubyte *where;
 	GLubyte a,r,g,b;
 
 	GLFlagError(context, width>256, GL_INVALID_VALUE);
 	GLFlagError(context, target!=GL_COLOR_TABLE, GL_INVALID_OPERATION);
 
-	palette = (GLubyte *)data;
+	palette = (const GLubyte *)data;
 	where   = (GLubyte *)context->PaletteData;
 
 	GLFlagError(context, where == NULL, GL_INVALID_OPERATION);
diff -urNp MiniGL~/src/vertexarray.c MiniGL/src/vertexarray.c
--- MiniGL~/src/vertexarray.c	2002-11-30 08:15:46.000000000 +0200
+++ MiniGL/src/vertexarray.c	2016-04-15 17:55:20.000000000 +0300
@@ -2067,7 +2067,7 @@ void GLInterleavedArrays(GLcontext conte
                 }
         break;
         default:
-                GLFlagError(context, 1, GL_INVALIE_ENUM);
+                GLFlagError(context, 1, GL_INVALID_ENUM);
                 context->ClientState = 0;
         break;
    }
diff -urNp MiniGL~/src/vertexbuffer.c MiniGL/src/vertexbuffer.c
--- MiniGL~/src/vertexbuffer.c	2002-11-30 08:15:46.000000000 +0200
+++ MiniGL/src/vertexbuffer.c	2016-07-01 07:01:10.000000000 +0300
@@ -37,7 +37,9 @@ This boolean is only set in the event of
 	#include <inline/timer_protos.h>
 #endif
 
+#if 0
 static char rcsid[] = "$Id: vertexbuffer.c,v 1.1.1.1 2000/04/07 19:44:51 hfrieden Exp $";
+#endif
 
 #ifdef __VBCC__
 extern void d_DrawPoints        (GLcontext context);
@@ -354,7 +356,7 @@ void GLColor3f(GLcontext context, GLfloa
 	context->UpdateCurrentColor = GL_TRUE;
 }
 
-void GLColor4fv(GLcontext context, GLfloat *v)
+void GLColor4fv(GLcontext context, const GLfloat *v)
 {
 	//LOG(2, glColor4fv, "%f %f %f %f", v[0], v[1], v[2], v[3]);
 
@@ -382,7 +384,7 @@ void GLColor4fv(GLcontext context, GLflo
 	context->UpdateCurrentColor = GL_TRUE;
 }
 
-void GLColor3fv(GLcontext context, GLfloat *v)
+void GLColor3fv(GLcontext context, const GLfloat *v)
 {
 	//LOG(2, glColor3fv, "%f %f %f", v[0], v[1], v[2]);
 
@@ -436,7 +438,7 @@ void GLColor3ub(GLcontext context, GLuby
 	context->UpdateCurrentColor = GL_TRUE;
 }
 
-void GLColor4ubv(GLcontext context, GLubyte *v)
+void GLColor4ubv(GLcontext context, const GLubyte *v)
 {
 	register W3D_Float f = 1/255.0;
 
@@ -450,7 +452,7 @@ void GLColor4ubv(GLcontext context, GLub
 	context->UpdateCurrentColor = GL_TRUE;
 }
 
-void GLColor3ubv(GLcontext context, GLubyte *v)
+void GLColor3ubv(GLcontext context, const GLubyte *v)
 {
 	register W3D_Float f = 1/255.0;
 	//LOG(2, glColor3ubv, "%f %f %f", v[0]*f, v[1]*f, v[2]*f);
@@ -501,7 +503,7 @@ void GLMultiTexCoord2fARB(GLcontext cont
 	}
 }
 
-void GLMultiTexCoord2fvARB(GLcontext context, GLenum unit, GLfloat *v)
+void GLMultiTexCoord2fvARB(GLcontext context, GLenum unit, const GLfloat *v)
 {
 	int u = unit - GL_TEXTURE0_ARB;
 
@@ -532,7 +534,7 @@ void GLTexCoord2f(GLcontext context, GLf
 	#undef thisvertex
 }
 
-void GLTexCoord2fv(GLcontext context, GLfloat *v)
+void GLTexCoord2fv(GLcontext context, const GLfloat *v)
 {
 	#define thisvertex context->VertexBuffer[context->VertexBufferPointer]
 
@@ -557,7 +559,7 @@ void GLTexCoord4f(GLcontext context, GLf
 	#undef thisvertex
 }
 
-void GLTexCoord4fv(GLcontext context, GLfloat *v)
+void GLTexCoord4fv(GLcontext context, const GLfloat *v)
 {
 	#define thisvertex context->VertexBuffer[context->VertexBufferPointer]
 
@@ -596,7 +598,7 @@ void GLVertex4f(GLcontext context, GLflo
 	#undef thisvertex
 }
 
-void GLVertex4fv(GLcontext context, GLfloat *v)
+void GLVertex4fv(GLcontext context, const GLfloat *v)
 {
 	#define thisvertex context->VertexBuffer[context->VertexBufferPointer]
 
@@ -619,7 +621,7 @@ void GLVertex4fv(GLcontext context, GLfl
 	#undef thisvertex
 }
 
-void GLVertex3fv(GLcontext context, GLfloat *v)
+void GLVertex3fv(GLcontext context, const GLfloat *v)
 {
 	#define thisvertex context->VertexBuffer[context->VertexBufferPointer]
 
@@ -667,7 +669,7 @@ void GLVertex2f(GLcontext context, GLflo
 	#undef thisvertex
 }
 
-void GLVertex2fv(GLcontext context, GLfloat *v)
+void GLVertex2fv(GLcontext context, const GLfloat *v)
 {
 	#define thisvertex context->VertexBuffer[context->VertexBufferPointer]
 
@@ -769,7 +771,7 @@ void GLArrayElement(GLcontext context, G
 {
 	context->ElementIndex[context->VertexBufferPointer++] = (UWORD)i;
 }
- 
+
 
 void GLEnd(GLcontext context)
 {
diff -urNp MiniGL~/src/vertexelements.c MiniGL/src/vertexelements.c
--- MiniGL~/src/vertexelements.c	2002-11-30 08:15:48.000000000 +0200
+++ MiniGL/src/vertexelements.c	2016-11-01 11:01:00.000000000 +0300
@@ -31,23 +31,19 @@ extern int AE_ClipTriangle(GLcontext con
 extern Convfn Convert;
 
 //NYI:
-static void E_DrawQuads         (GLcontext context, const int count, const UWORD *idx);
+static void E_DrawQuads         (GLcontext context, const int count, /*const*/ UWORD *idx);
 
-static void E_DrawQuadStrip     (GLcontext context, const int count, const UWORD *idx);
+static void E_DrawQuadStrip     (GLcontext context, const int count, /*const*/ UWORD *idx);
 
 //implemented:
 
-#ifndef __VBCC__
-static void E_DrawTriFan           (GLcontext context, const int count, const UWORD *idx);
-#else
-static void E_DrawTriFan           (GLcontext context, const int count, UWORD *idx);
-#endif
+static void E_DrawTriFan           (GLcontext context, const int count, /*const*/ UWORD *idx);
 
-static void E_DrawTriStrip         (GLcontext context, const int count, const UWORD *idx);
+static void E_DrawTriStrip         (GLcontext context, const int count, /*const*/ UWORD *idx);
 
-static void E_DrawTriangles     (GLcontext context, const int count, const UWORD *idx);
+static void E_DrawTriangles     (GLcontext context, const int count, /*const*/ UWORD *idx);
 
-static void E_DrawFlatFan       (GLcontext context, const int count, const UWORD *idx);
+static void E_DrawFlatFan       (GLcontext context, const int count, /*const*/ UWORD *idx);
 
 static PolyBuffer clipbuffer[MGL_MAXVERTS>>2];
 
@@ -864,7 +860,7 @@ static INLINE void V_ToScreen(GLcontext 
 
 
 
-static void E_DrawQuads(GLcontext context, const int count, const UWORD *idx)
+static void E_DrawQuads(GLcontext context, const int count, /*const*/ UWORD *idx)
 {
    int i;
    //quick hack
@@ -875,7 +871,7 @@ static void E_DrawQuads(GLcontext contex
    }
 }
 
-static void E_DrawQuadStrip(GLcontext context, const int count, const UWORD*idx)
+static void E_DrawQuadStrip(GLcontext context, const int count, /*const*/ UWORD*idx)
 {
    int i;
    int end;
@@ -890,11 +886,7 @@ static void E_DrawQuadStrip(GLcontext co
    }
 }
 
-#ifndef __VBCC__
-static void E_DrawTriFan(GLcontext context, const int count, const UWORD *idx)
-#else
-static void E_DrawTriFan(GLcontext context, const int count, UWORD *idx)
-#endif
+static void E_DrawTriFan(GLcontext context, const int count, /*const*/ UWORD *idx)
 {
       int i;
       int size;
@@ -1469,7 +1461,7 @@ static void E_DrawTriFan(GLcontext conte
 }
 
 
-static void E_DrawTriStrip(GLcontext context, const int count, const UWORD*idx)
+static void E_DrawTriStrip(GLcontext context, const int count, /*const*/ UWORD*idx)
 {
       int i;
       int size;
@@ -2234,7 +2226,7 @@ static void E_DrawTriangles_Locked(GLcon
 }
 
 
-static void E_DrawTriangles(GLcontext context, const int count, const UWORD*idx)
+static void E_DrawTriangles(GLcontext context, const int count, /*const*/ UWORD*idx)
 {
       int i;
       ULONG local_and, local_or;
@@ -2364,7 +2356,7 @@ static void E_DrawTriangles(GLcontext co
       }
 }
 
-static void E_DrawFlatFan(GLcontext context, const int count, const UWORD*idx)
+static void E_DrawFlatFan(GLcontext context, const int count, /*const*/ UWORD*idx)
 {
       int i;
       int vnum;
@@ -2770,12 +2762,11 @@ void GLDrawElements(GLcontext context, G
    if(count < 3)
         return; //invalid vertexcount or primitive
 
-   if(context->VertexArrayPipeline == GL_TRUE)
+   if(context->VertexArrayPipeline != GL_FALSE)
    switch(type)
    {
       case GL_UNSIGNED_SHORT:
                 idx = (UWORD*)indices;
-
       break;
 
       case GL_UNSIGNED_BYTE:
@@ -2788,11 +2779,10 @@ void GLDrawElements(GLcontext context, G
                 idx[2] = ub[2];
 
                 i = 3;
-
                 while (i < count)
                 {
                         idx[i] = ub[i];
-                i++;
+                        i++;
                 }
       break;
 
@@ -2809,11 +2799,10 @@ void GLDrawElements(GLcontext context, G
                 idx[2] = ul[2];
 
                 i = 3;
-
                 while (i < count)
                 {
                         idx[i] = ul[i];
-                i++;
+                        i++;
                 }
 
       break;
@@ -2933,7 +2922,7 @@ void GLDrawElements(GLcontext context, G
    if(context->VertexArrayPipeline == GL_FALSE)
    {
 	ULONG error;
-   	error = W3D_DrawElements(context->w3dContext, mode, type, count, (void*)indices);
+	error = W3D_DrawElements(context->w3dContext, mode, type, count, (void*)indices);
    }
    else
    {

diff -urNp MiniGL~/demos/addtest.c MiniGL/demos/addtest.c
--- MiniGL~/demos/addtest.c	2002-11-30 08:14:54.000000000 +0200
+++ MiniGL/demos/addtest.c	2016-04-15 17:55:10.000000000 +0300
@@ -6,6 +6,7 @@
 #define M_PI 3.14159265
 #endif
 #include <stdio.h>
+#include <string.h>
 
 GLint width=640; GLint height=480;
 GLfloat startilt = 0.0;
diff -urNp MiniGL~/demos/driverinfo.c MiniGL/demos/driverinfo.c
--- MiniGL~/demos/driverinfo.c	2002-11-30 08:14:56.000000000 +0200
+++ MiniGL/demos/driverinfo.c	2016-04-15 17:55:10.000000000 +0300
@@ -12,7 +12,7 @@
 
 #include <Warp3D/Warp3D.h>
 #ifdef __VBCC__
-	#include <proto/warp3d.h>
+	#include <proto/Warp3D.h>
 #else
 	#ifdef __GNUC__
 		#ifdef __PPC__
@@ -23,6 +23,11 @@
 	#elif defined(__STORM__)
 		#include <clib/Warp3D_protos.h>
 	#endif
+	#ifdef __PPC__
+	extern struct Library *Warp3DPPCBase;
+	#else
+	extern struct Library *Warp3DBase;
+	#endif
 #endif
 #include <stdio.h>
 #include <stdlib.h>
diff -urNp MiniGL~/demos/gears.c MiniGL/demos/gears.c
--- MiniGL~/demos/gears.c	2002-11-30 08:14:58.000000000 +0200
+++ MiniGL/demos/gears.c	2016-04-15 17:55:10.000000000 +0300
@@ -24,6 +24,7 @@
 #define M_PI 3.14159265
 #endif
 #include <stdio.h>
+#include <string.h>
 
 /* For portability... */
 #undef fcos
@@ -475,12 +476,12 @@ draw_outside(float w1, float w2, float r
 }
 
 Profile gear_profile[] =
-{0.000, 0.0,
-  0.300, 7.0,
-  0.340, 0.4,
-  0.550, 0.64,
-  0.600, 0.4,
-  0.950, 1.0
+{ {0.000, 0.0},
+  {0.300, 7.0},
+  {0.340, 0.4},
+  {0.550, 0.64},
+  {0.600, 0.4},
+  {0.950, 1.0}
 };
 
 float a1 = 27.0;
diff -urNp MiniGL~/demos/gears_stats.c MiniGL/demos/gears_stats.c
--- MiniGL~/demos/gears_stats.c	2002-11-30 08:14:58.000000000 +0200
+++ MiniGL/demos/gears_stats.c	2016-04-15 17:55:10.000000000 +0300
@@ -570,12 +570,12 @@ draw_outside(float w1, float w2, float r
 }
 
 Profile gear_profile[] =
-{0.000, 0.0,
-  0.300, 7.0,
-  0.340, 0.4,
-  0.550, 0.64,
-  0.600, 0.4,
-  0.950, 1.0
+{ {0.000, 0.0},
+  {0.300, 7.0},
+  {0.340, 0.4},
+  {0.550, 0.64},
+  {0.600, 0.4},
+  {0.950, 1.0}
 };
 
 float a1 = 27.0;
diff -urNp MiniGL~/demos/gravity.c MiniGL/demos/gravity.c
--- MiniGL~/demos/gravity.c	2002-11-30 08:14:58.000000000 +0200
+++ MiniGL/demos/gravity.c	2016-04-15 17:55:10.000000000 +0300
@@ -1,6 +1,7 @@
 #include <mgl/gl.h>
 
 #include <stdlib.h>
+#include <string.h>
 
 
 GLint width=640; GLint height=480;
@@ -214,18 +215,6 @@ void DoFrame(void)
 	mglSwitchDisplay();
 }
 
-#ifndef __VBCC__
-void keys(unsigned char c)
-{
-
-	switch (c)
-	{
-		case 0x1b:
-			mglExit();
-			break;
-	}
-}
-#else
 void keys(char c)
 {
 
@@ -236,13 +225,8 @@ void keys(char c)
 			break;
 	}
 }
-#endif
 
-#ifdef __VBCC__
 int
-#else
-void
-#endif
 main(int argc, char *argv[])
 {
 	int i;
@@ -283,7 +267,5 @@ main(int argc, char *argv[])
 
 	mglDeleteContext();
 	MGLTerm();
-#ifdef __VBCC__
 	return 0;
-#endif
 }
diff -urNp MiniGL~/demos/smtest.c MiniGL/demos/smtest.c
--- MiniGL~/demos/smtest.c	2002-11-30 08:15:00.000000000 +0200
+++ MiniGL/demos/smtest.c	2016-04-15 17:55:10.000000000 +0300
@@ -3,6 +3,7 @@
 
 
 #include <stdio.h>
+#include <string.h>
 #include <mgl/gl.h>
 
 #include <proto/dos.h>          // For Delay()
@@ -60,10 +61,10 @@ int main(int argc, char **argv)
 		Delay(100);
 
 
-		printf("Display info:\nDimensions:%d%d%d\n", li.width, li.height, li.depth);
-		printf("Pixel format: %d\n", li.pixel_format);
-		printf("Base address: 0x%x\n", li.base_address);
-		printf("Pitch: %d\n", li.pitch);
+		printf("Display info:\nDimensions:%lu%lu%lu\n", li.width, li.height, li.depth);
+		printf("Pixel format: %lu\n", li.pixel_format);
+		printf("Base address: 0x%x\n", (unsigned) li.base_address);
+		printf("Pitch: %lu\n", li.pitch);
 	}
 	else
 	{
diff -urNp MiniGL~/demos/texsub.c MiniGL/demos/texsub.c
--- MiniGL~/demos/texsub.c	2002-11-30 08:15:00.000000000 +0200
+++ MiniGL/demos/texsub.c	2016-04-15 17:55:10.000000000 +0300
@@ -53,6 +53,7 @@
 
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 #include <math.h>
 
 /*  Create checkerboard textures  */
